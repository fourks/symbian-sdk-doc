<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>CGraphicsContext</title>
<link href="../../../_stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css" media="screen"><!--
.ButtonBox { background-image: url(../../../_stock/gradient.jpg); }
--></style>
</head>
<body><a name="_top"></a><a name="2"></a>
<table width="100%" border="0" cellspacing="0"
cellpadding="0"><tbody><tr><td colspan=2 class="LogoBox"><a><img
src="../../../_stock/symbian.gif" alt="Symbian" width="121"
height="46" border="0"></a><img src="../../../_stock/mainheading.gif"
alt=" Developer Library" height="46" width="183"></td></tr><tr><td
class="DocSetBox" width="33%">
<p><a href="../../../Product/Generic/index.html">SYMBIAN OS V6.1 EDITION FOR C++</a></p>
</td><td class="ButtonBox" align="right" width="67%">
<p><a href="../../../_index/index.html"><img
src="../../../_stock/btn_index.gif" alt="[Index]" width="53"
height="22" border="0"></a> <a href="../../GlobalGlossary/index.html"><img src="../../../_stock/btn_glossary.gif"
alt="[Glossary]" border="0" width="81" height="22"></a> <img src="../../../_stock/btn_spacer.gif"
alt="" width="60" height="22"> <a href="index.html"><img src="../../../_stock/btn_prev.gif"
alt="[Previous]" border="0" width="85" height="22"></a> <a href="CGraphicsDeviceClass.html"><img src="../../../_stock/btn_next.gif" alt="[Next]"
border="0" width="58" height="22"></a></p>
</td></tr></table>
<hr noshade size="1">
<p class="breadcrumbNav">&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/index.html">Symbian&nbsp;OS&nbsp;v6.1&nbsp;Edition&nbsp;for&nbsp;C++</a>&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/APIReference/index.html">API&nbsp;Reference</a>&nbsp;<span class="separator">&#187;</span>
<a href="index.html">Graphics</a>&nbsp;<span class="separator">&#187;</span>
CGraphicsContext</p>

<hr noshade size="1">
<div class="AuthoredContent">

<p>Location:
<code> gdi.h </code>
<br>Link against: <code> gdi.lib </code>
</p>
</div><div class="Head1">
<a name="%3a%3aCGraphicsContext"></a>

<h1>Class <code>CGraphicsContext</code></h1>
</div><div class="Bodytext"><p class="Prototype"><code>CGraphicsContext</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Abstract, device independent, interface to graphics
contexts.</p>
<p> The class <code>CBitmapContext</code> is derived from this
class.</p>
<p>See <code>CGraphicsContext::Reset()</code> for the default settings
of a graphics context immediately after construction.</p>
<h4 class="subheading">Derivation</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr><td class="Cell"><code><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase">CBase</a></code></td><td class="Cell">Base class for all classes to be instantiated on the heap</td>
</tr>
<tr><td class="Cell"><code>CGraphicsContext</code></td><td class="Cell">Abstract, device independent, interface to graphics contexts</td>
</tr>
</table></td></tr></table>
<p>Defined in <code>CGraphicsContext</code>:
<br><code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aCancelClippingRect%28%29" title="Cancels any clipping rectangle">CancelClippingRect()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDevice%28%29" title="Gets a pointer to the graphics context's graphics device">Device()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDiscardBrushPattern%28%29" title="Discards a non-built-in brush pattern">DiscardBrushPattern()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDiscardFont%28%29" title="Discards a font">DiscardFont()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawArc%28%29" title="Draws an arc">DrawArc()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawBitmap%28%29" title="Draws a specified rectangle of a source bitmap to fit into a given destination rectangle">DrawBitmap()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawEllipse%28%29" title="Draws and fills an ellipse">DrawEllipse()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawLine%28%29" title="Draws a straight line between two points">DrawLine()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawLineBy%28%29" title="Draws a straight line relative to the current drawing point, using a vector">DrawLineBy()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawLineTo%28%29" title="Draws a straight line from the current drawing point to a specified point">DrawLineTo()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawPie%28%29" title="Draws and fills a pie slice">DrawPie()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawPolyLine%28%29" title="Draws a polyline from a set of points in a list">DrawPolyLine()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawPolygon%28%29" title="Draws and fills a polygon defined using a list of points">DrawPolygon()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawRect%28%29" title="Draws and fills a rectangle">DrawRect()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawRoundRect%28%29" title="Draws and fills a rectangle with rounded corners">DrawRoundRect()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawText%28%29" title="Reserved for future use">DrawText()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEAlternate" title="Only fill areas with odd winding numbers">EAlternate</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEAnd" title="8">EAnd</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aECenter" title="Text is centred">ECenter</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDashedPen" title="A dashed line">EDashedPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDiamondCrossHatchBrush" title="The brush fills with forward diagonal and rearward diagonal hatching -- lines going from bottom left to top right plus lines going from top left to bottom right -- giving the effect of a grid of small diamonds">EDiamondCrossHatchBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDotDashPen" title="A line of alternating dashes and dots">EDotDashPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDotDotDashPen" title="A line of alternating single dashes and pairs of dots">EDotDotDashPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDottedPen" title="A dotted line">EDottedPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeAND" title="Bitwise ANDs the pen and brush colours with the screen colour">EDrawModeAND</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeANDNOT" title="Inverts the screen colour before ANDing">EDrawModeANDNOT</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTAND" title="Inverts the pen and brush colours before ANDing">EDrawModeNOTAND</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTANDNOT" title="Inverts the screen and pen and brush colours before ANDing">EDrawModeNOTANDNOT</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTOR" title="Inverts the pen and brush colours before ORing">EDrawModeNOTOR</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTORNOT" title="NOT OR NOT mode">EDrawModeNOTORNOT</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTPEN" title="Inverts the pen and brush colours">EDrawModeNOTPEN</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTSCREEN" title="Inverts the colour of each pixel that is drawn over, (pen and brush attributes are ignored)">EDrawModeNOTSCREEN</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeNOTXOR" title="Inverts the pen and brush colours before XORing">EDrawModeNOTXOR</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeOR" title="Bitwise ORs the pen and brush colours with the screen colour">EDrawModeOR</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeORNOT" title="Inverts the screen, pen and brush colours before ORing">EDrawModeORNOT</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModePEN" title="Uses both pen and brush colour as they are">EDrawModePEN</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEDrawModeXOR" title="Bitwise XORs the pen and brush colours with the screen colour">EDrawModeXOR</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEForwardDiagonalHatchBrush" title="The brush fills with diagonal hatching -- lines going from bottom left to top right">EForwardDiagonalHatchBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEHorizontalHatchBrush" title="The brush fills with horizontal hatching -- lines going from left to right">EHorizontalHatchBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEInvertPen" title="16">EInvertPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEInvertScreen" title="1">EInvertScreen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aELeft" title="Text is left-aligned">ELeft</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aELogicalOp" title="14">ELogicalOp</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aENullBrush" title="The brush fill has no effect (default)">ENullBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aENullPen" title="The pen does not draw">ENullPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEOr" title="4">EOr</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEPatternedBrush" title="The brush fills with a selected bitmap pattern, set by UseBrushPattern()">EPatternedBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEPenmode" title="32">EPenmode</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aERearwardDiagonalHatchBrush" title="The brush fills with rearward diagonal hatching -- lines going from top left to bottom right">ERearwardDiagonalHatchBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aERight" title="Text is right-aligned">ERight</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aESolidBrush" title="The brush fills with a solid single colour, determined by SetBrushColor() and the drawing mode">ESolidBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aESolidPen" title="A solid line (default)">ESolidPen</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aESquareCrossHatchBrush" title="The brush fills with horizontal and vertical hatching -- lines going from left to right plus lines going from top to bottom -- giving the effect of a grid of small squares">ESquareCrossHatchBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEVerticalHatchBrush" title="The brush fills with vertical hatching -- lines going from top to bottom">EVerticalHatchBrush</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEWinding" title="Fill areas with winding numbers greater than zero">EWinding</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aEXor" title="2">EXor</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aJustificationInPixels%28%29" title="Gets the amount of space in pixels by which to adjust letter or word spacing, given the total number of words and spaces, a start space, and the number of units to be adjusted">JustificationInPixels()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aMoveBy%28%29" title="Sets the drawing point relative to the current co-ordinates">MoveBy()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aMoveTo%28%29" title="Sets the drawing point relative to the co-ordinate origin">MoveTo()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aPlot%28%29" title="Draws a single point">Plot()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aReset%28%29" title="Resets the graphics context to its default settings:">Reset()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetBrushColor%28%29" title="Sets the brush colour">SetBrushColor()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetBrushOrigin%28%29" title="Sets the brush pattern origin">SetBrushOrigin()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetBrushStyle%28%29" title="Sets the brush style">SetBrushStyle()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetCharJustification%28%29" title="Sets character justification">SetCharJustification()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetClippingRect%28%29" title="Sets the clipping rectangle">SetClippingRect()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetDrawMode%28%29" title="Sets the drawing mode">SetDrawMode()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetOrigin%28%29" title="Sets the position of the co-ordinate origin">SetOrigin()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetPenColor%28%29" title="Sets the pen colour">SetPenColor()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetPenSize%28%29" title="Sets the line drawing size for the pen">SetPenSize()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetPenStyle%28%29" title="Sets the line drawing style for the pen">SetPenStyle()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetStrikethroughStyle%28%29" title="Sets the strikethrough style">SetStrikethroughStyle()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetUnderlineStyle%28%29" title="Sets the underline style">SetUnderlineStyle()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetWordJustification%28%29" title="Adjusts the spaces between words to stretch or squeeze to a certain width">SetWordJustification()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTBrushStyle" title="Brush styles">TBrushStyle</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTDrawMode" title="Drawing modes">TDrawMode</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTDrawModeComponents" title="Drawing mode components">TDrawModeComponents</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTDrawTextParam" title="Reserved for future use">TDrawTextParam</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTFillRule" title="Rules used to fill self crossing polygons">TFillRule</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTPenStyle" title="Pen styles">TPenStyle</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTTextAlign" title="Text alignment">TTextAlign</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aUseBrushPattern%28%29" title="Sets the brush pattern to the specified bitmap">UseBrushPattern()</a></code>, <code class="ApiItem"><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aUseFont%28%29" title="Sets the device font to be used for text drawing">UseFont()</a></code>
</p>
<p>Inherited from <code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase" title="Base class for all classes to be instantiated on the heap">CBase</a></code>:
<br><code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase%3a%3aoperator%20new%28%29" title="Allocates the object from the heap and then initialises its contents to binary zeroes">operator new()</a></code></p>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="../Bitmaps/CBitmapContextClass.html#%3a%3aCBitmapContext" title="An abstract, device-independent, interface to bitmapped graphics contexts"><code class="ApiItem">CBitmapContext</code></a></li>
</ul>
<a name="2.7"></a>
</div><div class="Head2">
<hr size="2" noshade>
<h2>Graphics device</h2>
</div><div class="Bodytext">
<a name="2.7.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDevice%28%29"></a>
<hr size="1" noshade>
<h3><code>Device()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual CGraphicsDevice* Device() const=0;</code></p><h4 class="subheading">Description</h4>
<p>Gets a pointer to the graphics context&#8217;s graphics
device.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CGraphicsDevice* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the graphics device. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Resetting</h2>
</div><div class="Bodytext">
<a name="2.8.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aReset%28%29"></a>
<hr size="1" noshade>
<h3><code>Reset()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void Reset()=0;</code></p><h4 class="subheading">Description</h4>
<p>Resets the graphics context to its default settings:</p>
<ul>
<li>
<p>the drawing mode is <code>TDrawMode::EDrawModePen</code>
(pen and brush colours used as they are)</p>
</li>
<li>
<p>there is no clipping rectangle</p>
</li>
<li>
<p>the pen settings are: black, solid, single pixel
size</p>
</li>
<li>
<p>the brush style is null</p>
</li>
<li>
<p>no text font is selected</p>
</li>
</ul>
<a name="2.9"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Drawing control</h2>
</div><div class="Bodytext">
<a name="2.9.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetDrawMode%28%29"></a>
<hr size="1" noshade>
<h3><code>SetDrawMode()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetDrawMode(TDrawMode aDrawingMode)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the drawing mode. </p>
<p>The way that the pen and brush draw depends on the drawing
mode. The drawing mode affects the colour that is actually drawn, because it
defines the way that the current screen colour logically combines with the
current pen colour and brush colour. There are 13 drawing modes, each giving
different logical combinations of pen, brush and screen colours. Each mode is
produced by ORing together different combinations of seven drawing mode
components.</p>
<p>The three most important modes are
<code>TDrawMode::EDrawModePEN</code>,
<code>TDrawMode::EDrawModeNOTSCREEN</code> and
<code>TDrawMode::EDrawModeXOR</code>. The default drawing mode is
<code>TDrawMode::EDrawModePEN</code>.</p>
<p>The drawing mode is over-ridden for line and shape drawing
functions when a wide pen line has been selected. It is forced to
<code>TDrawMode::EDrawModePEN</code>. This is to prevent undesired effects at
line joins (vertexes).</p>
<p>Notes</p>
<p><code>TDrawMode::EDrawModeAND</code> gives a &quot;colour filter&quot;
effect. For example:</p>
<ul>
<li>
<p>ANDing with white gives the original colour</p>
</li>
<li>
<p>ANDing with black gives black</p>
</li>
</ul>
<p><code>TDrawMode::EDrawModeOR</code> gives a &quot;colour boost&quot;
effect. For example:</p>
<ul>
<li>
<p>ORing with black gives the original colour</p>
</li>
<li>
<p>ORing with white gives white</p>
</li>
</ul>
<p><code>TDrawMode::EDrawModeXOR</code> gives an &quot;Exclusive OR&quot;
effect. For example:</p>
<ul>
<li>
<p>white XOR black gives white</p>
</li>
<li>
<p>white XOR white gives black</p>
</li>
<li>
<p>black XOR black gives black</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TDrawMode aDrawingMode </code></td>
<td class="Cell"><p class="ValueDesc">
</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTDrawMode" title="Drawing modes"><code class="ApiItem">CGraphicsContext::TDrawMode</code></a></li>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTDrawModeComponents" title="Drawing mode components"><code class="ApiItem">CGraphicsContext::TDrawModeComponents</code></a></li>
</ul>
<a name="2.9.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetOrigin%28%29"></a>
<hr size="1" noshade>
<h3><code>SetOrigin()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetOrigin(const TPoint&amp; aPos=TPoint(0,0))=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the position of the co-ordinate origin.</p>
<p>All subsequent drawing operations are done relative to this
origin.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPos </code></td>
<td class="Cell"><p class="ValueDesc"> The origin. The default origin is
<code>TPoint(0,0)</code>&#0160;&#8212; the top left corner of the screen.
</p></td>
</tr>
</table></td></tr></table>
<a name="2.10"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>The internal drawing position</h2>
</div><div class="Bodytext">
<a name="2.10.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aMoveTo%28%29"></a>
<hr size="1" noshade>
<h3><code>MoveTo()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void MoveTo(const TPoint&amp; aPoint)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the drawing point relative to the co-ordinate origin.
</p>
<p>A subsequent call to <code>DrawLineTo()</code> or
<code>DrawLineBy()</code> uses the new drawing point as the start point for the
line drawn.</p>
<p>Notes</p>
<ul>
<li>
<p>The operations <code>DrawLine()</code>,
<code>DrawLineTo()</code>, <code>DrawLineBy()</code> and
<code>DrawPolyline()</code> also change the internal drawing position to the
last point of the drawn line(s). </p>
</li>
<li>
<p>The internal drawing position is set to the co-ordinate
origin if no drawing or moving operations have yet taken place.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPoint </code></td>
<td class="Cell"><p class="ValueDesc"> The new internal drawing position. </p></td>
</tr>
</table></td></tr></table>
<a name="2.10.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aMoveBy%28%29"></a>
<hr size="1" noshade>
<h3><code>MoveBy()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void MoveBy(const TPoint&amp; aVector)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the drawing point relative to the current
co-ordinates.</p>
<p>A subsequent call to <code>DrawLineTo()</code> or
<code>DrawLineBy()</code> uses the new drawing point as the start point for the
line drawn.</p>
<p>Notes</p>
<ul>
<li>
<p>The operations <code>DrawLine()</code>,
<code>DrawLineTo()</code>, <code>DrawLineBy()</code> and
<code>DrawPolyline()</code> also change the internal drawing position to the
last point of the drawn line(s). </p>
</li>
<li>
<p>The internal drawing position is set to the co-ordinate
origin if no drawing or moving operations have yet taken place.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aVector </code></td>
<td class="Cell"><p class="ValueDesc"> The amount by which the internal drawing position is to
move.</p></td>
</tr>
</table></td></tr></table>
<a name="2.11"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Clipping</h2>
</div><div class="Bodytext">
<a name="2.11.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetClippingRect%28%29"></a>
<hr size="1" noshade>
<h3><code>SetClippingRect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetClippingRect(const TRect&amp; aRect)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the clipping rectangle.</p>
<p>The area of visible drawing depends on the clipping region. The
default clipping rectangle is the full device area.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aRect </code></td>
<td class="Cell"><p class="ValueDesc"> The clipping rectangle. </p></td>
</tr>
</table></td></tr></table>
<a name="2.11.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aCancelClippingRect%28%29"></a>
<hr size="1" noshade>
<h3><code>CancelClippingRect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void CancelClippingRect()=0;</code></p><h4 class="subheading">Description</h4>
<p>Cancels any clipping rectangle.</p>
<p>Clipping thus reverts to the full device area, the
default.</p>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetClippingRect%28%29" title="Sets the clipping rectangle"><code class="ApiItem">SetClippingRect()</code></a></li>
</ul>
<a name="2.12"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Pen control</h2>
</div><div class="Bodytext">
<a name="2.12.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetPenColor%28%29"></a>
<hr size="1" noshade>
<h3><code>SetPenColor()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetPenColor(const TRgb&amp; aColor)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the pen colour.</p>
<p>The effective pen colour depends on the drawing mode. The
default pen colour is black.</p>
<p>Note:</p>
<ul>
<li>
<p>The pen is used to draw lines, the outlines of filled
shapes, and text. The class provides member functions to set the colour of the
pen, the style of line and the line size drawn.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRgb&amp; aColor </code></td>
<td class="Cell"><p class="ValueDesc"> An RGB colour for the pen. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetDrawMode%28%29" title="Sets the drawing mode"><code class="ApiItem">CGraphicsContext::SetDrawMode()</code></a></li>
</ul>
<a name="2.12.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetPenStyle%28%29"></a>
<hr size="1" noshade>
<h3><code>SetPenStyle()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetPenStyle(TPenStyle aPenStyle)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the line drawing style for the pen. </p>
<p>There are 6 pen styles. If no pen style is set, then the
default is <code>TPenStyle::ESolidPen</code>. To use a pen style, its full
context must be given, e.g. for a null pen:</p>
<p class="CodeBlock"><code>CGraphicsContext::TPenStyle::ENullPen</code></p>
<p>Notes:</p>
<ul>
<li>
<p>The pen is used to draw lines, the outlines of filled
shapes, and text. <code>CGraphicsContext</code> member functions are provided
to set the colour of the pen, the style of line and the line size drawn.</p>
</li>
<li>
<p>The <code>TPenStyle::ENullPen</code> style should be used
if a border is not required around a filled shape.</p>
</li>
<li>
<p>Dotted and dashed pen styles have a device dependant
implementation, always give single-pixel size lines on the
screen&nbsp;&#8212; whatever the pen size set by
<code>SetPenSize()</code>&nbsp;&#8212; and can only be used for straight
lines, polylines, non-rounded rectangles and polygons.</p>
</li>
</ul>
<p>The dotted/dashed pattern is continued, without re-starting,
for all consecutively drawn straight lines, i.e.</p>
<ul>
<li>
<p>the outlines of rectangles&nbsp;&#8212; the pattern
starts in the top left corner. It is reset at the end of the function
call.</p>
</li>
<li>
<p>the outlines of polygons&nbsp;&#8212; the pattern starts
at the first point. It is reset at the end of the function call.</p>
</li>
<li>
<p>polylines and straight lines&nbsp;&#8212; the pattern
starts at the first point initially. Consecutive calls to
<code>DrawLine()</code> and/or <code>DrawPolyLine()</code>, whether the lines
are concatenated or not, continue the pattern. It can be reset by a further
call to <code>SetPenStyle()</code> using the same dotted/dashed style
parameter.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TPenStyle aPenStyle </code></td>
<td class="Cell"><p class="ValueDesc"> A pen style. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTPenStyle" title="Pen styles"><code class="ApiItem">CGraphicsContext::TPenStyle</code></a></li>
</ul>
<a name="2.12.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetPenSize%28%29"></a>
<hr size="1" noshade>
<h3><code>SetPenSize()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetPenSize(const TSize&amp; aSize)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the line drawing size for the pen.</p>
<p>Lines of size greater than one pixel:</p>
<ul>
<li>
<p>are drawn with rounded ends that extend beyond the end
points, (as if the line is drawn using a circular pen tip of the specified
size).</p>
</li>
<li>
<p>are always drawn in <code>TDrawMode::EDrawModePEN</code>
mode, overriding whatever mode has been set using
<code>SetDrawMode()</code>.</p>
</li>
</ul>
<p>Notes:</p>
<ul>
<li>
<p>The pen is used to draw lines, the outlines of filled
shapes, and text. The class provides member functions to set the colour of the
pen, the style of line and the line size drawn.</p>
</li>
<li>
<p>Wide straight lines and arcs have rounded ends so that
concatenated wide lines have smoothly rounded corners at the vertexes.</p>
</li>
<li>
<p>When lines are made wide, the extra strips of pixels are
added equally to both sides of the line. This works precisely for lines of odd
pixel size (3,&nbsp;5,&nbsp;7,&nbsp;etc.). Wide lines of even pixel
size, (2,&nbsp;4,&nbsp;6,&nbsp;etc.), have the extra strip of pixels
added to the right and/or below the line.</p>
</li>
<li>
<p>Wide outlines of ellipses and wide line arcs are drawn with
the pixels distributed either side of a thin (single pixel wide) true ellipse
constructed in the normal manner. Wide ellipses and arcs of even pixel size
have the extra strip of pixels added to the right and/or below the curved line.
This gives a slight asymmetry to ellipses.</p>
</li>
<li>
<p>If the pen style is dotted or dashed, the size
specification is ignored: a single-pixel wide primitive is drawn, (this is
device dependant).</p>
</li>
<li>
<p>A line size of zero is handled as if the pen style had been
set to <code>TPenStyle::ENullPen</code>.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TSize&amp; aSize </code></td>
<td class="Cell"><p class="ValueDesc"> A line size. The default is 1 pixel. </p></td>
</tr>
</table></td></tr></table>
<a name="2.13"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Brush control</h2>
</div><div class="Bodytext">
<a name="2.13.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetBrushColor%28%29"></a>
<hr size="1" noshade>
<h3><code>SetBrushColor()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetBrushColor(const TRgb&amp; aColor)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the brush colour.</p>
<p>The effective brush colour depends on the drawing mode.</p>
<p>Notes:</p>
<ul>
<li>
<p>The brush is used for filling shapes and the background of
text boxes. The brush has colour, style, pattern and pattern origin
parameters.</p>
</li>
<li>
<p>If no brush colour has been set, it defaults to white.
However the default brush style is null, so when drawing to a window the
default appears to be the window&#8217;s background colour.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRgb&amp; aColor </code></td>
<td class="Cell"><p class="ValueDesc"> An RGB colour for the brush. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetDrawMode%28%29" title="Sets the drawing mode"><code class="ApiItem">SetDrawMode()</code></a></li>
</ul>
<a name="2.13.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetBrushStyle%28%29"></a>
<hr size="1" noshade>
<h3><code>SetBrushStyle()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetBrushStyle(TBrushStyle aBrushStyle)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the brush style.</p>
<p>Ten brush styles are provided, including six built-in hatching
patterns (see <code>TBrushStyle</code>).</p>
<p>Note:</p>
<ul>
<li>
<p>The brush is used for filling shapes and the background of
text boxes. The brush has colour, style, pattern and pattern origin
parameters.</p>
</li>
<li>
<p>Use <code>TBrushStyle::ENullBrush</code> to draw the
outline of a fillable shape on its own, without filling.</p>
</li>
<li>
<p>If the <code>TBrushStyle::EPatternedBrush</code> style is
set, but no bitmap pattern has been selected using
<code>UseBrushPattern()</code>, then the function panics.</p>
</li>
<li>
<p>Hatching lines are done in the current brush colour, set
using <code>SetBrushColor()</code>. Hatching can be overlaid on other graphics.
The hatching pattern starts at the brush origin, set using
<code>SetBrushOrigin()</code>.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TBrushStyle aBrushStyle </code></td>
<td class="Cell"><p class="ValueDesc"> A brush style. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aTBrushStyle" title="Brush styles"><code class="ApiItem">CGraphicsContext::TBrushStyle</code></a></li>
</ul>
<a name="2.13.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetBrushOrigin%28%29"></a>
<hr size="1" noshade>
<h3><code>SetBrushOrigin()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetBrushOrigin(const TPoint&amp; aOrigin)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the brush pattern origin.</p>
<p>This specifies the position of the pixel in the top left corner
of a reference pattern tile, (in absolute device co-ordinates). Other copies of
the pattern file are then tiled around the reference one. Thus the brush origin
can be set as the top left corner of a shape.</p>
<p>The brush pattern may be a built-in style, or a bitmap. To use
a bitmap, the brush must have a pattern set and the brush style must be set to
<code>TBrushStyle::EPatternedBrush</code>.</p>
<p>Notes</p>
<ul>
<li>
<p>The brush is used for filling shapes and the background of
text boxes. The brush has colour, style, pattern and pattern origin
parameters.</p>
</li>
<li>
<p>If <code>SetBrushOrigin()</code> is not used, then the
origin defaults to (0,0).</p>
</li>
<li>
<p>This brush origin remains in effect for all fillable shapes
drawn subsequently, until a new brush origin is set. Shapes can thus be
considered as windows onto a continuous pattern field (covering the whole
clipping region of a screen device, or the whole device area of a
printer).</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aOrigin </code></td>
<td class="Cell"><p class="ValueDesc"> An origin point for the brush. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetBrushStyle%28%29" title="Sets the brush style"><code class="ApiItem">SetBrushStyle()</code></a></li>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aUseBrushPattern%28%29" title="Sets the brush pattern to the specified bitmap"><code class="ApiItem">UseBrushPattern()</code></a></li>
</ul>
<a name="2.13.5"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aUseBrushPattern%28%29"></a>
<hr size="1" noshade>
<h3><code>UseBrushPattern()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void UseBrushPattern(const CFbsBitmap* aBitmap)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the brush pattern to the specified bitmap.</p>
<p> For the brush to actually use the bitmap,
<code>TBrushStyle::EPatternedBrush</code> must be used to set the brush
style.</p>
<p>When the brush pattern is no longer required, use
<code>DiscardBrushPattern()</code> to free up the memory used, if the bitmap is
not being shared. If <code>UseBrushPattern()</code> is used again without using
<code>DiscardBrushPattern()</code> then the previous pattern is discarded
automatically.</p>
<p>Notes:</p>
<ul>
<li>
<p>The brush is used for filling shapes and the background of
text boxes. The brush has colour, style, pattern and pattern origin
parameters.</p>
</li>
<li>
<p>When loading a bitmap, the bitmap is checked to see if it
is already in memory. If the bitmap is already there, then that copy is
shared.</p>
</li>
<li>
<p>The brush does not need to have a pattern set at all. There
are several built-in hatching patterns which can be selected using
<code>SetBrushStyle()</code>.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const CFbsBitmap* aBitmap </code></td>
<td class="Cell"><p class="ValueDesc"> A bitmap pattern for the brush. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetBrushStyle%28%29" title="Sets the brush style"><code class="ApiItem">SetBrushStyle()</code></a></li>
</ul>
<a name="2.13.6"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDiscardBrushPattern%28%29"></a>
<hr size="1" noshade>
<h3><code>DiscardBrushPattern()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DiscardBrushPattern()=0;</code></p><h4 class="subheading">Description</h4>
<p>Discards a non-built-in brush pattern.</p>
<p>This frees up the memory used by the bitmap, if it is not being
shared by another process.</p>
<p>Notes:</p>
<ul>
<li>
<p>The brush is used for filling shapes and the background of
text boxes. The brush has colour, style, pattern and pattern origin
parameters.</p>
</li>
<li>
<p>If <code>DiscardBrushPattern()</code> is used, with no
brush pattern set, then there is no effect.</p>
</li>
</ul>
<a name="2.14"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Text control</h2>
</div><div class="Bodytext">
<a name="2.14.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aUseFont%28%29"></a>
<hr size="1" noshade>
<h3><code>UseFont()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void UseFont(const CFont* aFont)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the device font to be used for text drawing.</p>
<p> If the font is already in memory, then that copy is
shared.</p>
<p>Notes:</p>
<ul>
<li>
<p>The <code>CFont*</code> argument must have been previously
initialised by calling <code>MGraphicsDeviceMap::GetNearestFontInTwips()</code>
with the required font-specification. If the <code>CFont*</code> has not been
initialised correctly, and therefore does not point to an available
font-bitmap, then a panic is raised.</p>
</li>
<li>
<p>When the font is no longer required, use
<code>DiscardFont()</code> to free up the memory used. If
<code>UseFont()</code> is used again without using <code>DiscardFont()</code>
then the previous font is discarded automatically.</p>
</li>
<li>
<p>If no font has been selected, and an attempt is made to
draw text with <code>DrawText()</code>, then a panic is raised.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const CFont* aFont </code></td>
<td class="Cell"><p class="ValueDesc"> A device font </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="MGraphicsDeviceMapClass.html#%3a%3aMGraphicsDeviceMap%3a%3aGetNearestFontInTwips%28%29" title="Gets the nearest font to that in the given font specification"><code class="ApiItem">MGraphicsDeviceMap::GetNearestFontInTwips()</code></a></li>
</ul>
<a name="2.14.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDiscardFont%28%29"></a>
<hr size="1" noshade>
<h3><code>DiscardFont()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DiscardFont()=0;</code></p><h4 class="subheading">Description</h4>
<p>Discards a font.</p>
<p>This frees up the memory used, if the font is not being
shared.</p>
<p>The function can be called when no font is in
use.</p>
<a name="2.14.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetWordJustification%28%29"></a>
<hr size="1" noshade>
<h3><code>SetWordJustification()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetWordJustification(TInt aExcessWidth,TInt aNumGaps)=0;</code></p><h4 class="subheading">Description</h4>
<p>Adjusts the spaces between words to stretch or squeeze to a
certain width.</p>
<p>The function is required by the Text Views API, and is not
intended for regular use by developers.</p>
<p>The text line that is to be justified has a certain number of
gaps (spaces) between the words. It also has a distance (in pixels) between the
end of the last word and the actual end of the line (right hand margin,
usually). These excess width pixels are distributed amongst the gaps between
the words to achieve full justification of the text line. Spaces become fat
spaces to keep underlining/strikethrough consistent. Pixels are distributed to
the inter-word gaps starting from the left end of the string. The spacing
between characters in each word remains unchanged.</p>
<p>After a call to <code>SetWordJustification()</code>, subsequent
calls to either of the two <code>DrawText()</code> functions are affected until
the number of spaces specified by <code>aNumSpaces</code> is used up.</p>
<p>The easiest way to find out the excess width and number of
spaces is to call <code>CFont::MeasureText()</code>. This function can also
perform counting, which is finding how much of some text will fit into a given
width.</p>
<p>Use <code>CFont::TextCount()</code> to return the excess
width.</p>
<p>For example, in the string &quot;To be, or not to be&quot;, there are
five inter-word gaps. If there are six excess pixels they will be distributed
in the proportion 2, 1, 1, 1, 1 between the words. If there are nine excess
pixels they will be distributed in the proportion 2, 2, 2, 2, 1 between the
words.</p>
<p></p>
<p>Notes:</p>
<ul>
<li>
<p>If the excess width is zero, then calling
<code>SetWordJustification()</code> has no effect.</p>
</li>
<li>
<p>At first sight it may appear that
<code>SetWordJustification()</code> is not required because you can simply call
<code>DrawText()</code> for each word. However, underlined justified text does
not work using this strategy&#0160;&#8212;  you get a non-underlined gap between the
space and the beginning of the next word.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aExcessWidth </code></td>
<td class="Cell"><p class="ValueDesc"> The width (in pixels) to be distributed between the specified
number of spaces. It may be positive, in which case the text is stretched, or
negative, in which case it is shrunk. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aNumGaps </code></td>
<td class="Cell"><p class="ValueDesc"> The number of word spaces (characters with the code U+0020)
over which the change in width is distributed. </p></td>
</tr>
</table></td></tr></table>
<a name="2.14.5"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetCharJustification%28%29"></a>
<hr size="1" noshade>
<h3><code>SetCharJustification()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetCharJustification(TInt aExcessWidth,TInt aNumChars)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets character justification.</p>
<p>This function is required by the Text Views API, and is not
intended for regular use by developers.</p>
<p>It affects the strings of text used in the calls to
<code>DrawText()</code> that follow, until the number of characters drawn
equals <code>aNumChars</code>.</p>
<p>The text line that is to be justified has a certain number of
characters&nbsp;&#8212; this includes the spaces between the words. It also
has a distance (in pixels) between the end of the last word and the actual end
of the line (right hand margin, usually). These excess width pixels are
distributed amongst all the characters, increasing the gaps between them, to
achieve full justification of the text line.</p>
<p>Use <code>CFont::TextCount()</code> to return the excess
width.</p>
<p>Notes:</p>
<ul>
<li>
<p>This function is provided to allow simulation of printer
fonts on screen. Due to the fact that fully-scalable fonts are not used before
ER5, large printer fonts can be simulated by using the nearest smaller font and
widening it slightly.</p>
</li>
<li>
<p>If the excess width is zero, then calling
<code>SetCharJustification()</code> has no effect.</p>
</li>
<li>
<p><code>SetCharJustification()</code> is required for WYSIWYG
where the layout uses printer font metrics but screen fonts have to be drawn on
the screen. Because continuously scalable typefaces (c.f. TrueType) are not
used before ER5 and because screen fonts are coarser and less numerous in their
variety than the printer fonts, the best matching smaller screen font must be
used with character justification to simulate the printer font on the
screen.</p>
</li>
<li>
<p>There is also a situation where the gaps between characters
on screen have to be reduced with character clipping. The screen font that best
matches the printer font may have the required height, but has characters that
are too wide. A line of text that works on the printer will then be too long on
the screen, unless it is squashed horizontally. The number of pixels that
overlap the end of the screen line must now be removed from the gaps between
the characters, i.e. there is a negative excess width. This situation is
especially important where adding a TAB on screen gives perfectly acceptable
printout, but would push the last character of the line off the right hand side
of the screen.</p>
</li>
</ul>
<p>In practice what you do in printer layout mode is:</p>
<ul>
<li>
<p>Calculate where the line breaks will come on the printer.
To do this you use a printer font (which in practice means a table of character
widths of the font that the printer will use).</p>
</li>
<li>
<p>Now change to use a screen font that is the closest font
which is no taller that the printer font. In practice it will often be fatter
maybe only for certain characters such as 'i'.</p>
</li>
<li>
<p>You have to recalculate the width of the characters using
the screen fonts. You can do this using <code>CFont::TextWidth</code>() as you
have already determined how many characters will fit on the line.</p>
</li>
<li>
<p>If, in the screen font, the characters are not as wide as
the line then you can just use word justification to expand the line. You would
only do this if the text is to be justified.</p>
</li>
<li>
<p>If, however, the characters are wider than the line then
you would use character justification to clip each character. You would need to
do this even if the line is not justified.</p>
</li>
</ul>
<p>Thus, in practice, character justification will only very
rarely be used to expand a line of characters.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aExcessWidth </code></td>
<td class="Cell"><p class="ValueDesc"> The excess width (in pixels) to be distributed between the
specified number of characters. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aNumChars </code></td>
<td class="Cell"><p class="ValueDesc"> The number of characters involved. </p></td>
</tr>
</table></td></tr></table>
<a name="2.14.6"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aJustificationInPixels%28%29"></a>
<hr size="1" noshade>
<h3><code>JustificationInPixels()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt JustificationInPixels(TInt&amp; aExcessPixels,TInt&amp; aTotalUnits);</code></p><h4 class="subheading">Description</h4>
<p>Gets the amount of space in pixels by which to adjust the
current letter or word spacing, and also retrieves the number of excess pixels
and word spaces remaining after the adjustment is performed. </p>
<p>The arguments are the number of remaining pixels (character
groups) and units (word spaces) over which justification is to occur. The
function can be called repetitively until the number of units is zero, and
hence justification is complete. A panic occurs if the number of units is less
than one or the amount of pixels is zero.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aExcessPixels </code></td>
<td class="Cell"><p class="ValueDesc"> The number of pixels by which the width of the text is to be
changed. It may be positive, in which case the text is stretched, or negative,
in which case it is shrunk. On return, this is equal to its old value minus the
return value. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aTotalUnits </code></td>
<td class="Cell"><p class="ValueDesc"> The number of word spaces over which the change in width is to
be distributed. On return, this is reduced by one. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of pixels to be added to the width of the current
unit. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetWordJustification%28%29" title="Adjusts the spaces between words to stretch or squeeze to a certain width"><code class="ApiItem">SetWordJustification()</code></a></li>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetCharJustification%28%29" title="Sets character justification"><code class="ApiItem">SetCharJustification()</code></a></li>
</ul>
<a name="2.14.7"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aJustificationInPixels%28%29"></a>
<hr size="1" noshade>
<h3><code>JustificationInPixels()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt JustificationInPixels(TInt aExcessPixels,TInt aTotalUnits,TInt aFirstUnit,TInt aNumUnits);</code></p><h4 class="subheading">Description</h4>
<p>Gets the amount of space in pixels by which to adjust letter or
word spacing, given the total number of words and spaces, a start space, and
the number of units to be adjusted.</p>
<p>The first two arguments are the number of pixels (character
groups) and the number of units (word spaces) over which justification is to
occur. The third argument specifies the current character group or word space,
while the final argument specifies the number of units that are to be
adjusted.</p>
<p>A panic occurs if <code>aExcessPixels</code> is 0,
<code>aTotalUnits</code> is not greater than 0, or <code>aFirstUnit</code> is
not less than <code>aTotalUnits</code>. </p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aExcessPixels </code></td>
<td class="Cell"><p class="ValueDesc"> The number of pixels by which the width of the text is to be
changed. It may be positive, in which case the text is stretched, or negative,
in which case it is shrunk. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aTotalUnits </code></td>
<td class="Cell"><p class="ValueDesc"> The number of word spaces over which the change in width is to
be distributed. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aFirstUnit </code></td>
<td class="Cell"><p class="ValueDesc"> The current unit&#0160;&#8212; the character group or word
space we are 'on'. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aNumUnits </code></td>
<td class="Cell"><p class="ValueDesc"> The number of units that are to be adjusted&#0160;&#8212;
starting at <code>aFirstUnit</code>. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of pixels to be added to the width of the current
unit. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetWordJustification%28%29" title="Adjusts the spaces between words to stretch or squeeze to a certain width"><code class="ApiItem">SetWordJustification()</code></a></li>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetCharJustification%28%29" title="Sets character justification"><code class="ApiItem">SetCharJustification()</code></a></li>
</ul>
<a name="2.15"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Setting font styles</h2>
</div><div class="Bodytext">
<a name="2.15.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetUnderlineStyle%28%29"></a>
<hr size="1" noshade>
<h3><code>SetUnderlineStyle()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetUnderlineStyle(TFontUnderline aUnderlineStyle)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the underline style.</p>
<p>This is applied to all subsequently drawn text.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TFontUnderline aUnderlineStyle </code></td>
<td class="Cell"><p class="ValueDesc"> The underline style&#0160;&#8212; on or off. </p></td>
</tr>
</table></td></tr></table>
<a name="2.15.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aSetStrikethroughStyle%28%29"></a>
<hr size="1" noshade>
<h3><code>SetStrikethroughStyle()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetStrikethroughStyle(TFontStrikethrough aStrikethroughStyle)=0;</code></p><h4 class="subheading">Description</h4>
<p>Sets the strikethrough style.</p>
<p>This is applied to all subsequently drawn text.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TFontStrikethrough aStrikethroughStyle </code></td>
<td class="Cell"><p class="ValueDesc"> The strikethrough style&#0160;&#8212; on or off. </p></td>
</tr>
</table></td></tr></table>
<a name="2.16"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Point drawing</h2>
</div><div class="Bodytext">
<a name="2.16.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aPlot%28%29"></a>
<hr size="1" noshade>
<h3><code>Plot()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void Plot(const TPoint&amp; aPoint)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a single point. The point is drawn with the current pen
settings using the current drawing mode.</p>
<p>Note:</p>
<ul>
<li>
<p>If the pen size is greater than one pixel, a filled circle
of the current pen colour is drawn, with the pen size as the diameter and the
plotted point as the centre. If the pen size is an even number of pixels, the
extra pixels are drawn below and to the right of the centre.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPoint </code></td>
<td class="Cell"><p class="ValueDesc"> The point to be drawn.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aSetPenSize%28%29" title="Sets the line drawing size for the pen"><code class="ApiItem">SetPenSize()</code></a></li>
</ul>
<a name="2.17"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Non-fillable shape drawing</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>There are a number of important facts regarding all line
drawing:</p>
<p>Straight lines can be drawn between two given points, to a single
given point from the current internal drawing position, or by moving the
internal drawing position by a given vector.</p>
<p>Functions are provided to draw straight lines, polylines
(concatenated sequences of straight lines) and curved arcs.</p>
<ul>
<li>
<p>All lines are drawn with the current pen settings using the
current drawing mode.</p>
</li>
<li>
<p>Straight lines, one pixel wide, are drawn without their final
point. This enables sequences of concatenated lines to be easily drawn with
each pixel only being drawn once.</p>
</li>
<li>
<p>If the pen size is greater than one pixel, a straight line is
drawn as a rectangular shaped region of pixels, with rounded ends that extend
beyond the start and end points.</p>
</li>
</ul>
<a name="2.17.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawLine%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawLine()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawLine(const TPoint&amp; aPoint1,const TPoint&amp; aPoint2)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a straight line between two points.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPoint1 </code></td>
<td class="Cell"><p class="ValueDesc"> The point at the start of the line. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPoint2 </code></td>
<td class="Cell"><p class="ValueDesc"> The point at the end of the line. </p></td>
</tr>
</table></td></tr></table>
<a name="2.17.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawLineTo%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawLineTo()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawLineTo(const TPoint&amp; aPoint)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a straight line from the current drawing point to a
specified point.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPoint </code></td>
<td class="Cell"><p class="ValueDesc"> The point at the end of the line. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aMoveTo%28%29" title="Sets the drawing point relative to the co-ordinate origin"><code class="ApiItem">MoveTo()</code></a></li>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aMoveBy%28%29" title="Sets the drawing point relative to the current co-ordinates"><code class="ApiItem">MoveBy()</code></a></li>
</ul>
<a name="2.17.5"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawLineBy%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawLineBy()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawLineBy(const TPoint&amp; aVector)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a straight line relative to the current drawing point,
using a vector.</p>
<p>The start point of the line is the current drawing point. The
specified vector is added to the drawing point to give the end point of the
line</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aVector </code></td>
<td class="Cell"><p class="ValueDesc"> The vector to add to the current internal drawing position,
giving the end point of the line. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aMoveTo%28%29" title="Sets the drawing point relative to the co-ordinate origin"><code class="ApiItem">MoveTo()</code></a></li>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aMoveBy%28%29" title="Sets the drawing point relative to the current co-ordinates"><code class="ApiItem">MoveBy()</code></a></li>
</ul>
<a name="2.17.6"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawPolyLine%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawPolyLine()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawPolyLine(const CArrayFix&lt;TPoint&gt;* aPointList)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a polyline from a set of points in an array.</p>
<p> A polyline is a series of concatenated straight lines joining
a set of points.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const CArrayFix&lt;TPoint&gt;* aPointList </code></td>
<td class="Cell"><p class="ValueDesc"> An array containing the points on the polyline. </p></td>
</tr>
</table></td></tr></table>
<a name="2.17.7"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawPolyLine%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawPolyLine()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawPolyLine(const TPoint* aPointList,TInt aNumPoints)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a polyline from a set of points in a list.</p>
<p>A polyline is a series of concatenated straight lines joining a
set of points.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint* aPointList </code></td>
<td class="Cell"><p class="ValueDesc"> Pointer to a set of points on the polyline.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aNumPoints </code></td>
<td class="Cell"><p class="ValueDesc"> Number of points in the list.</p></td>
</tr>
</table></td></tr></table>
<a name="2.17.8"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawArc%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawArc()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawArc(const TRect&amp; aRect,const TPoint&amp; aStart,const TPoint&amp; aEnd)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws an arc.</p>
<p>The arc is considered a portion of an ellipse. The ellipse is
defined by the <code>TRect</code> argument.</p>
<p>The pixels at both the start point and the end point are
drawn.</p>
<p>The arc itself is the segment of the ellipse drawn in an
anti-clockwise direction from the start point to the end point.</p>
<p>Notes:</p>
<ul>
<li>
<p>A rectangle is used in the construction of the ellipse of
which the arc is a segment. This rectangle is passed as an argument of type
<code>TRect</code>.</p>
</li>
<li>
<p>A wide line arc is drawn with the pixels distributed either
side of a true ellipse, in such a way that the outer edge of the line would
touch the edge of the construction rectangle. In other words, the ellipse used
to construct it is slightly smaller than that for a single pixel line
size.</p>
</li>
<li>
<p>If the specified start or end point is at the centre of the
ellipse, then the line that defines the start or end of the arc defaults to one
extending vertically above the centre point.</p>
</li>
<li>
<p>If the start and end point are the same point or are points
on the same line through the ellipse centre then a complete unfilled ellipse is
drawn.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aRect </code></td>
<td class="Cell"><p class="ValueDesc"> A rectangle in which to draw the ellipse, of which the arc is
a segment. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aStart </code></td>
<td class="Cell"><p class="ValueDesc"> The point defining the start of the arc. It defines one end of
a line from the geometric centre of the ellipse. The point of intersection
between this line and the ellipse defines the start point of the arc.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aEnd </code></td>
<td class="Cell"><p class="ValueDesc">The point defining the end of the arc. It defines one end of a
second line from the geometric centre of the ellipse. The point of intersection
between this line and the ellipse defines the end point of the arc.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawEllipse%28%29" title="Draws and fills an ellipse"><code class="ApiItem">DrawEllipse()</code></a></li>
</ul>
<a name="2.18"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Fillable shape drawing</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>All the fillable shape drawing primitives, except
<code>DrawPolygon()</code>, either use a rectangle directly or use it to define
the position of an ellipse. This rectangle is passed as an argument of type
<code>TRect</code>.</p>
<p>The outlines are drawn with the pen, and the shapes are filled
with the brush. Set the pen or brush to null to omit drawing of either
component. All shapes are clipped to the current clipping region.</p>
<p>Shapes are filled using the brush, and thus subject to the brush
style (colour, hash or pattern) and brush pattern origin. The effective fill
colour depends on the drawing mode. The brush style should be set to
<code>TBrushStyle::ENullBrush</code> if no fill is required.</p>
<p>The outlines of fillable shapes are drawn with the pen, and thus
subject to pen colour, pen size and pen style settings. The effective outline
colour depends on the drawing mode. Straight lines are drawn between vertexes
in the same way that lines are drawn using <code>DrawLine()</code>, with each
point being drawn only once, (see <code>SetPenSize()</code> for a discussion of
line size effects). If the pen size has been set to greater than or equal to
half the size of the shape then the shape will be filled with solid pen colour.
The pen style should be set to <code>TPenStyle::ENullPen</code> if no outline
is required.</p>
<p>There are five shape drawing primitives: pie slice, ellipse,
rectangle, rounded rectangle, and polygon. All may be drawn with or without an
outline.</p>
<a name="2.18.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawRect%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawRect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawRect(const TRect&amp; aRect)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws and fills a rectangle.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aRect </code></td>
<td class="Cell"><p class="ValueDesc"> The rectangle to be drawn. </p></td>
</tr>
</table></td></tr></table>
<a name="2.18.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawEllipse%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawEllipse()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawEllipse(const TRect&amp; aRect)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws and fills an ellipse.</p>
<p>The ellipse is drawn inside the rectangle defined by the
<code>TRect</code> argument. Any rectangle that has odd pixel dimensions, has
the bottom right corner trimmed to give even pixel dimensions before the
ellipse is constructed.</p>
<p>Note:</p>
<ul>
<li>
<p>A wide outline ellipse is drawn with the pixels distributed
either side of a true ellipse, in such a way that the outer edge of the line
touches the edge of the construction rectangle. In other words, the ellipse
used to construct it is smaller than that for a single pixel line size.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aRect </code></td>
<td class="Cell"><p class="ValueDesc">The rectangle in which the ellipse is drawn. </p></td>
</tr>
</table></td></tr></table>
<a name="2.18.5"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawRoundRect%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawRoundRect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawRoundRect(const TRect&amp; aRect,const TSize&amp; aCornerSize)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws and fills a rectangle with rounded corners.</p>
<p>The rounded corners are each constructed as an arc of an
ellipse.</p>
<p>The line drawn by the pen, if any, goes inside the specified
rectangle.</p>
<p>Notes:</p>
<ul>
<li>
<p>Dotted and dashed pen styles cannot be used for the outline
of a rounded rectangle.</p>
</li>
<li>
<p>If either corner size dimension is greater than half the
corresponding rectangle length, the corner size dimension is reduced to half
the rectangle size.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aRect </code></td>
<td class="Cell"><p class="ValueDesc">The rectangle to be drawn. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TSize&amp; aCornerSize </code></td>
<td class="Cell"><p class="ValueDesc"> The dimensions of each corner. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CGraphicsContextClass.html#%3a%3aCGraphicsContext%3a%3aDrawArc%28%29" title="Draws an arc"><code class="ApiItem">DrawArc()</code></a></li>
</ul>
<a name="2.18.6"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawPie%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawPie()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawPie(const TRect&amp; aRect,const TPoint&amp; aStart,const TPoint&amp; aEnd)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws and fills a pie slice.</p>
<p>The pie slice is an area bounded by:</p>
<ul>
<li>
<p>the arc of an ellipse drawn in an anticlockwise direction
from the start point to the end point</p>
</li>
<li>
<p>the straight line drawn to the start point from the
geometric centre of the ellipse.</p>
</li>
<li>
<p>the straight line to the end point from the geometric
centre of the ellipse.</p>
</li>
</ul>
<p></p>
<p>Notes:</p>
<ul>
<li>
<p>A rectangle is used in the construction of the pie slice.
This rectangle is passed as an argument of type <code>TRect</code>. The curved
edge of the pie slice is an arc of an ellipse constructed within the
rectangle.</p>
</li>
<li>
<p>The line drawn by the pen goes inside the specified
rectangle.</p>
</li>
<li>
<p>The pixels at the end point of the arc are not
drawn.</p>
</li>
<li>
<p>A wide line edged pie slice has the arc drawn with the
pixels distributed either side of a true ellipse. This is done in such a way
that the outer edge of the line touches the edge of the construction rectangle.
In other words, the ellipse used to construct it is slightly smaller than that
for a single pixel line size.</p>
</li>
<li>
<p>If the specified start or end point is at the centre of the
ellipse, then the line that defines the start or end of the arc defaults to one
extending vertically above the centre point.</p>
</li>
<li>
<p>If the start and end point are the same point or are points
on the same line through the ellipse centre then a complete filled ellipse is
drawn. A line is also drawn from the edge to the ellipse centre.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aRect </code></td>
<td class="Cell"><p class="ValueDesc"> A rectangle in which to draw the ellipse bounding the pie
slice. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aStart </code></td>
<td class="Cell"><p class="ValueDesc"> A point defining the start of the arc bounding the pie slice.
It defines one end of a line from the geometrical centre of the ellipse. The
point of intersection between this line and the ellipse defines the start point
of the arc.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aEnd </code></td>
<td class="Cell"><p class="ValueDesc"> A point to define the end of the arc bounding the pie slice.
It defines one end of a second line from the geometrical centre of the ellipse.
The point of intersection between this line and the ellipse defines the end
point of the arc.</p></td>
</tr>
</table></td></tr></table>
<a name="2.18.7"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawPolygon%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawPolygon()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TInt DrawPolygon(const CArrayFix&lt;TPoint&gt;* aPointList,TFillRule aFillRule=EAlternate)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws and fills a polygon defined using an array of
points.</p>
<p>The first point in the array defines the start of the first
side of the polygon. The second point defines the second vertex (the end point
of the first side and the start point of the second side).</p>
<p> The final side of the polygon is drawn using the last point
from the array, and the line is drawn to the start point of the first
side.</p>
<p>Self-crossing polygons are filled according to the specified
fill rule.</p><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const CArrayFix&lt;TPoint&gt;* aPointList </code></td>
<td class="Cell"><p class="ValueDesc"> An array of points, specifying the vertices of the
polygon.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TFillRule aFillRule </code></td>
<td class="Cell"><p class="ValueDesc"> The fill rule. By default, this is
<code>TFillRule::EAlternate</code>. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc">
<code>KErrNone</code>, if successful; otherwise, another of
the system-wide error codes. </p></td>
</tr>
</table></td></tr></table>
<a name="2.18.8"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawPolygon%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawPolygon()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TInt DrawPolygon(const TPoint* aPointList,TInt aNumPoints,TFillRule aFillRule=EAlternate)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws and fills a polygon defined using a list of
points.</p>
<p>The first point in the list defines the start of the first side
of the polygon. The second point defines the second vertex (the end point of
the first side and the start point of the second side).</p>
<p>The final side of the polygon is drawn using the last point
from the list, and the line is drawn to the start point of the first
side.</p>
<p>Self-crossing polygons are filled according to the specified
fill rule.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint* aPointList </code></td>
<td class="Cell"><p class="ValueDesc"> Pointer to list of points, specifying the vertices of the
polygon.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aNumPoints </code></td>
<td class="Cell"><p class="ValueDesc"> The number of points in the list.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TFillRule aFillRule=EAlternate </code></td>
<td class="Cell"><p class="ValueDesc"> The fill rule. By default this is
<code>TFillRule::EAlternate</code>. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc">
<code>KErrNone</code>, if successful; otherwise, another of
the system-wide error codes. </p></td>
</tr>
</table></td></tr></table>
<a name="2.19"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Text drawing</h2>
</div><div class="Bodytext">
<a name="2.19.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawText%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawText()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawText(const TDesC&amp; aString,const TPoint&amp; aPosition)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws text without a surrounding box. </p>
<p>The text baseline is aligned with the y co-ordinate of the
specified point, and the left end of the text is aligned with the left end of
the text.</p>
<p>Note:</p>
<ul>
<li>
<p>Text drawing is done with the pen, and is subject to the
pen colour. The effective text colour also depends on the drawing mode. The
size and style of the text depends on the font used. The layout of the text
depends on the justification mode set.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC&amp; aString </code></td>
<td class="Cell"><p class="ValueDesc"> The text string to be drawn. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aPosition </code></td>
<td class="Cell"><p class="ValueDesc"> A point specifying the position of the left end of the text.
</p></td>
</tr>
</table></td></tr></table>
<a name="2.19.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawText%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawText()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawText(const TDesC&amp; aString,const TRect&amp; aBox,TInt aBaselineOffset,TTextAlign aHoriz=ELeft,TInt aLeftMrg=0)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws text inside a box.</p>
<p>The surrounding box is filled with the current brush colour
(not a pattern) and is drawn without any outline. The effective box colour
depends on the drawing mode&nbsp;&#8212; if a brush colour has not been set
then the brush defaults to white. The brush may be set to
<code>TBrushStyle::ENullBrush</code> if text positioning relative to a box is
required, but the box should not be filled.</p>
<p>The font used is that set by <code>UseFont()</code>. If no font
is in use then a panic occurs.</p>
<p>The alignment of the text within the box can be
specified.</p>
<p>Text drawn within a box is also clipped to that box. Unless you
intend to clip the top off the text, <code>aBaselineOffset</code> should be
greater than or equal to the ascent of the current font.</p>
<p>Offsets:</p>
<ul>
<li>
<p>If the offset is negative, zero, or less than font height
this is handled as would be expected, i.e. no text will be seen in the box in
the first two instances, and the top of the text will be clipped in the latter
case.</p>
</li>
</ul>
<p>Margins:</p>
<ul>
<li>
<p>For the drawing of right-aligned text, <code>aMargin</code>
indicates the margin from the right of <code>aBox</code>&#0160;&#8212;  where a
positive value results in a leftwards offset. </p>
</li>
<li>
<p>Negative margins can be used to display portions of the
text string clipped by the box. A negative margin for left aligned text would
clip the start of the text string. Similarly, a negative margin for right
aligned text would clip the end of the text string.</p>
</li>
<li>
<p>If the margin is greater than the width of the box then no
text will be visible.</p>
</li>
<li>
<p>The margin is still honoured for centred text&#0160;&#8212;
centred text will not be centred in the box, unless the margin is zero.</p>
</li>
</ul>
<p>Note:</p>
<ul>
<li>
<p>Text drawing is done with the pen, and is thus subject to
the pen colour. The effective text colour also depends on the drawing mode. The
size and style of the text depends on the used font. The layout of the text
depends on the justification mode set.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC&amp; aString </code></td>
<td class="Cell"><p class="ValueDesc"> The text string to be drawn. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aBox </code></td>
<td class="Cell"><p class="ValueDesc"> The box to draw the text in. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aBaselineOffset </code></td>
<td class="Cell"><p class="ValueDesc"> An offset from the top of the box to the text baseline.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TTextAlign aHoriz </code></td>
<td class="Cell"><p class="ValueDesc"> The text alignment mode&#0160;&#8212; default is left
aligned. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftMrg </code></td>
<td class="Cell"><p class="ValueDesc"> The left margin for left-aligned text, or the right margin for
right-aligned text&#0160;&#8212; default is zero. </p></td>
</tr>
</table></td></tr></table>
<a name="2.19.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawText%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawText()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawText(const TDesC&amp; aString,const TPoint&amp; aPosition,const TDrawTextParam&amp; aParam);</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Reserved for future use.</p>
<a name="2.20"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Bitmap drawing</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>The actual &#8216;real world&#8217; size of a bitmap is given
in twips. A bitmap also has x and y dimensions in pixels. There are therefore
two ways that a bitmap can be drawn to a graphics device:</p>
<ul>
<li>
<p>starting at a certain point, stretched or compressed to its
size in twips</p>
</li>
<li>
<p>stretched or compressed to fit a rectangle of a given size
and position</p>
</li>
</ul>
<a name="2.20.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawBitmap%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawBitmap()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawBitmap(const TPoint&amp; aTopLeft,const CFbsBitmap* aSource)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a bitmap at the specified point.</p>
<p>The point specifies the top left hand corner of the bitmap. The
bitmap is compressed or stretched based on its internally stored size in
twips.</p>
<p>Notes:</p>
<ul>
<li>
<p>This member function uses the bitmap's size in twips and
does a stretch/compress blit using a linear&nbsp;DDA.</p>
</li>
<li>
<p>As this function scales the bitmap, it is unavoidably slow.
Therefore, where possible, use <code>CBitmapContext::BitBlt()</code> instead.
If the bitmap has to be scaled, consider creating another bitmap along with an
<code>CFbsBitmapDevice</code> etc., doing <code>DrawBitmap()</code> once and
using <code>BitBlt()</code> subsequently.</p>
</li>
<li>
<p>Note that all bitmaps are clipped to the device
boundaries.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TPoint&amp; aTopLeft </code></td>
<td class="Cell"><p class="ValueDesc"> The point where the top left pixel of the bitmap is to be
drawn </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const CFbsBitmap* aSource </code></td>
<td class="Cell"><p class="ValueDesc"> A source bitmap </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="TLinearDDAClass.html#%3a%3aTLinearDDA" title="Linear digital differential analyser"><code class="ApiItem">TLinearDDA</code></a></li>
</ul>
<a name="2.20.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawBitmap%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawBitmap()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawBitmap(const TRect&amp; aDestRect,const CFbsBitmap* aSource)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a bitmap to fit a given rectangle. </p>
<p>The bitmap is compressed or stretched based on its internally
stored size in pixels.</p>
<p>Notes:</p>
<ul>
<li>
<p>This member function uses the bitmap's size in pixels and
does a stretch/compress blit using a linear&nbsp;DDA.</p>
</li>
<li>
<p>As this function scales the bitmap, it is unavoidably slow.
Therefore, where possible, use <code>CBitmapContext::BitBlt()</code> instead.
If the bitmap has to be scaled, consider creating another bitmap along with an
<code>CFbsBitmapDevice</code> etc., doing <code>DrawBitmap()</code> once and
using <code>BitBlt()</code> subsequently.</p>
</li>
<li>
<p>Note that all bitmaps are clipped to the device
boundaries.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aDestRect </code></td>
<td class="Cell"><p class="ValueDesc"> The rectangle within which the bitmap is to be drawn. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const CFbsBitmap* aSource </code></td>
<td class="Cell"><p class="ValueDesc"> A source bitmap. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="TLinearDDAClass.html#%3a%3aTLinearDDA" title="Linear digital differential analyser"><code class="ApiItem">TLinearDDA</code></a></li>
</ul>
<a name="2.20.5"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aDrawBitmap%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawBitmap()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void DrawBitmap(const TRect&amp; aDestRect,const CFbsBitmap* aSource,const TRect&amp; aSourceRect)=0;</code></p><h4 class="subheading">Description</h4>
<p>Draws a specified rectangle of a source bitmap to fit into a
given destination rectangle.</p>
<p>Notes:</p>
<ul>
<li>
<p>This member function uses rectangle sizes in pixels and
does a stretch/compress blit using a linear&nbsp;DDA.</p>
</li>
<li>
<p>As this function scales the bitmap, it is unavoidably slow.
Therefore, where possible, use <code>CBitmapContext::BitBlt()</code> instead.
If the bitmap has to be scaled, consider creating another bitmap along with an
<code>CFbsBitmapDevice</code> etc., doing <code>DrawBitmap()</code> once and
using <code>BitBlt()</code> subsequently.</p>
</li>
<li>
<p>Note that all bitmaps are clipped to the device
boundaries.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aDestRect </code></td>
<td class="Cell"><p class="ValueDesc"> The rectangle within which the bitmap is to be drawn. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const CFbsBitmap* aSource </code></td>
<td class="Cell"><p class="ValueDesc"> A source bitmap. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TRect&amp; aSourceRect </code></td>
<td class="Cell"><p class="ValueDesc"> The rectangle in the source bitmap that is copied to the
destination rectangle. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="TLinearDDAClass.html#%3a%3aTLinearDDA" title="Linear digital differential analyser"><code class="ApiItem">TLinearDDA</code></a></li>
</ul>
<a name="2.21"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Enumerations</h2>
</div><div class="Bodytext">
<a name="2.21.2"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTBrushStyle"></a>
<hr size="1" noshade>
<h3>Enum <code>TBrushStyle</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBrushStyle</code></p><h4 class="subheading">Description</h4>
<p>Brush styles.</p><table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aENullBrush"><code class="Value">ENullBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fill has no effect (default).</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aESolidBrush"><code class="Value">ESolidBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with a solid single colour, determined by
<code>SetBrushColor()</code> and the drawing mode.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEPatternedBrush"><code class="Value">EPatternedBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with a selected bitmap pattern, set by
<code>UseBrushPattern().</code></para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEVerticalHatchBrush"><code class="Value">EVerticalHatchBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with vertical hatching&#0160;&#8212; lines
going from top to bottom.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEForwardDiagonalHatchBrush"><code class="Value">EForwardDiagonalHatchBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with diagonal hatching&#0160;&#8212; lines
going from bottom left to top right.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEHorizontalHatchBrush"><code class="Value">EHorizontalHatchBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with horizontal hatching&#0160;&#8212;
lines going from left to right.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aERearwardDiagonalHatchBrush"><code class="Value">ERearwardDiagonalHatchBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with rearward diagonal
hatching&#0160;&#8212; lines going from top left to bottom right.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aESquareCrossHatchBrush"><code class="Value">ESquareCrossHatchBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with horizontal and vertical
hatching&#0160;&#8212; lines going from left to right plus lines going from
top to bottom&#0160;&#8212; giving the effect of a grid of small
squares</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDiamondCrossHatchBrush"><code class="Value">EDiamondCrossHatchBrush</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The brush fills with forward diagonal and rearward diagonal
hatching&#0160;&#8212; lines going from bottom left to top right plus lines
going from top left to bottom right&#0160;&#8212; giving the effect of a grid
of small diamonds.</para>
</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.3"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTDrawModeComponents"></a>
<hr size="1" noshade>
<h3>Enum <code>TDrawModeComponents</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TDrawModeComponents</code></p><h4 class="subheading">Description</h4>
<p>Drawing mode components.</p>
<p>This enum is not intended to be used directly, but provides
components for the easy specification of drawing modes in the
<code>TDrawMode</code> enum.</p><table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEInvertScreen"><code class="Value">EInvertScreen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>1</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEXor"><code class="Value">EXor</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>2</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEOr"><code class="Value">EOr</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>4</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEAnd"><code class="Value">EAnd</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>8</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aELogicalOp"><code class="Value">ELogicalOp</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>14</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEInvertPen"><code class="Value">EInvertPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>16</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEPenmode"><code class="Value">EPenmode</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>32</para>
</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.4"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTDrawMode"></a>
<hr size="1" noshade>
<h3>Enum <code>TDrawMode</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TDrawMode</code></p><h4 class="subheading">Description</h4>
<p>Drawing modes.</p>
<p>This enum builds on the drawing mode components in the
<code>TDrawModeComponents</code> enum.</p>
<p>If the pen colour is <code>p</code>, brush colour is
<code>b</code> and screen colour is <code>s</code>, the effect of
<code>TDrawMode::EDrawModeAND</code> is <code>P=p&amp;s</code> and
<code>B=b&amp;s</code>. In other words, the effective colour of the pen on the
screen, <code>P</code>, is that produced by the bitwise ANDing of the current
screen colour and the current pen colour. The effect is similar for the
effective brush colour, <code>B</code>.</p>
<p>The effective pen and brush colour are given in the table using
the key</p>
<ul>
<li>
<p>Inputs: pen colour is p, brush colour is b and screen
colour is s</p>
</li>
<li>
<p>Outputs: effective brush colour is B, effective pen colour
is P.</p>
</li>
</ul><table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeAND"><code class="Value">EDrawModeAND</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Bitwise ANDs the pen and brush colours with the screen
colour. P=p&amp;s, B=b&amp;s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTAND"><code class="Value">EDrawModeNOTAND</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the pen and brush colours before ANDing.
P=(~p)&amp;s, B=(~b)&amp;s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModePEN"><code class="Value">EDrawModePEN</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Uses both pen and brush colour as they are. P=p, B=b</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeANDNOT"><code class="Value">EDrawModeANDNOT</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the screen colour before ANDing. P=p&amp;(~s),
B=b&amp;(~s)</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeXOR"><code class="Value">EDrawModeXOR</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Bitwise XORs the pen and brush colours with the screen
colour. P=p^s, B=b^s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeOR"><code class="Value">EDrawModeOR</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Bitwise ORs the pen and brush colours with the screen colour.
P=p|s, B=b|s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTANDNOT"><code class="Value">EDrawModeNOTANDNOT</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the screen and pen and brush colours before ANDing.
P=(~p)&amp;(~s), B=(~b)&amp;(~s)</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTXOR"><code class="Value">EDrawModeNOTXOR</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the pen and brush colours before XORing. P=(~p)^s,
B=(~b)^s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTSCREEN"><code class="Value">EDrawModeNOTSCREEN</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the colour of each pixel that is drawn over, (pen and
brush attributes are ignored). P=~s, B=~s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTOR"><code class="Value">EDrawModeNOTOR</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the pen and brush colours before ORing. P=(~p)|s,
B=(~b)|s</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTPEN"><code class="Value">EDrawModeNOTPEN</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the pen and brush colours. P=~p, B=~b</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeORNOT"><code class="Value">EDrawModeORNOT</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Inverts the screen, pen and brush colours before ORing.
P=p|(~s), B=b|(~s)</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDrawModeNOTORNOT"><code class="Value">EDrawModeNOTORNOT</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>NOT OR NOT mode. P=(~p)|(~s), B=(~b)|(~s)</para>
</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.5"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTFillRule"></a>
<hr size="1" noshade>
<h3>Enum <code>TFillRule</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TFillRule</code></p><h4 class="subheading">Description</h4>
<p>Rules used to fill self crossing polygons. </p>
<p>The filling of a polygon proceeds as follows: for a given point
in the polygon, then</p>
<ul>
<li>
<p>if the rule is <code>TFillRule::EAlternate</code> (default)
and it has an odd winding number, then fill the surrounding area.</p>
</li>
<li>
<p>if the rule is <code>TFillRule::EWinding</code> and it has
a winding number greater than zero, then fill the surrounding area.</p>
</li>
</ul>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEAlternate"><code class="Value">EAlternate</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Only fill areas with odd winding numbers.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEWinding"><code class="Value">EWinding</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Fill areas with winding numbers greater than zero.</para>
</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.6"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTPenStyle"></a>
<hr size="1" noshade>
<h3>Enum <code>TPenStyle</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TPenStyle</code></p><h4 class="subheading">Description</h4>
<p>Pen styles. The screen pattern unit in each definition below
describes the pattern drawn by the line&nbsp;&#8212; 1 represents a pixel
drawn, 0 represents a pixel that is not affected.</p><table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aENullPen"><code class="Value">ENullPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>The pen does not draw. Screen pattern unit = 00&#8230;</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aESolidPen"><code class="Value">ESolidPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>A solid line (default). Screen pattern unit = 11&#8230;</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDottedPen"><code class="Value">EDottedPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>A dotted line. Screen pattern unit = 1000&#8230;</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDashedPen"><code class="Value">EDashedPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>A dashed line. Screen pattern unit = 111000&#8230;</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDotDashPen"><code class="Value">EDotDashPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>A line of alternating dashes and dots. Screen pattern unit =
1111001100...</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aEDotDotDashPen"><code class="Value">EDotDotDashPen</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>A line of alternating single dashes and pairs of dots. Screen
pattern unit = 11110011001100...</para>
</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.7"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTTextAlign"></a>
<hr size="1" noshade>
<h3>Enum <code>TTextAlign</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TTextAlign</code></p><h4 class="subheading">Description</h4>
<p>Text alignment.</p><table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aELeft"><code class="Value">ELeft</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Text is left-aligned.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aECenter"><code class="Value">ECenter</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Text is centred.</para>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><a name="%3a%3aCGraphicsContext%3a%3aERight"><code class="Value">ERight</code></a></td>
<td class="Cell"><p class="ValueDesc">
<para>Text is right-aligned.</para>
</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.8"></a></div><div class="Head3">
<a name="%3a%3aCGraphicsContext%3a%3aTDrawTextParam"></a>
<hr size="1" noshade>
<h3>Struct <code>TDrawTextParam</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TDrawTextParam</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Reserved for future use.</p>

</div><div class="Footer">
<hr noshade size="1">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td><p class="copyrightStatement">Copyright &copy;2002&nbsp; Symbian Ltd. &nbsp; &nbsp; &nbsp;	6.1-00174
</p></td>
<td align="right"><p><a href="#_top"><img
alt="[Top]" src="../../../_stock/arrow_up.gif" border="0"
align="bottom"></a></p></td>
</table>
</div>
</body>
</html>
