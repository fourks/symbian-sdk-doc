<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>CnvUtilities</title>
<link href="../../../stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css" media="screen"><!--
.ButtonBox { background-image: url(../../../stock/gradient.jpg); }
--></style>
</head>
<body><a name="_top"></a><a name="2"></a>
<table width="100%" border="0" cellspacing="0"
cellpadding="0"><tbody><tr><td colspan=2 class="LogoBox"><a><img
src="../../../stock/symbian.gif" alt="Symbian" width="121"
height="46" border="0"></a><img src="../../../stock/mainheading.gif"
alt=" Developer Library" height="46" width="183"></td></tr><tr><td
class="DocSetBox" width="33%">
<p><a href="../../../Product/Generic/index.html">SYMBIAN OS V6.1 EDITION FOR C++</a></p>
</td><td class="ButtonBox" align="right" width="67%">
<p><a href="../../../_index/index.html"><img
src="../../../stock/btn_index.gif" alt="[Index]" width="53"
height="22" border="0"></a> <a href="../../GlobalGlossary/index.html"><img src="../../../stock/btn_glossary.gif"
alt="[Glossary]" border="0" width="81" height="22"></a> <img src="../../../stock/btn_spacer.gif"
alt="" width="60" height="22"> <a href="index.html"><img src="../../../stock/btn_prev.gif"
alt="[Previous]" border="0" width="85" height="22"></a> <a href="ConvertFromUnicodeFunction.html"><img src="../../../stock/btn_next.gif" alt="[Next]"
border="0" width="58" height="22"></a></p>
</td></tr></table>
<hr noshade size="1">
<p class="breadcrumbNav">&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/index.html">Symbian&nbsp;OS&nbsp;v6.1&nbsp;Edition&nbsp;for&nbsp;C++</a>&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/APIReference/index.html">API&nbsp;Reference</a>&nbsp;<span class="separator">&#187;</span>
<a href="index.html">Character&nbsp;Conversion&nbsp;Plug-In&nbsp;Provider</a>&nbsp;<span class="separator">&#187;</span>
CnvUtilities</p>

<hr noshade size="1">
<div class="AuthoredContent">

<p>Location:
<code> convutils.h </code>
<br>Link against: <code> convutils.lib </code>
</p>
</div><div class="Head1">
<a name="%3a%3aCnvUtilities"></a>

<h1>Class <code>CnvUtilities</code></h1>
</div><div class="Bodytext"><p class="Prototype"><code>CnvUtilities</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Provides static character conversion utilities for complex
encodings. Its functions may be called from a plug-in DLL's implementation of
<code>ConvertFromUnicode()</code> and <code>ConvertToUnicode()</code>.</p>
<p>These utility functions are provided for use when converting
to/from complex character set encodings, including modal encodings. Modal
encodings are those where the interpretation of a given byte of data is
dependent on the current mode; mode changing is performed by escape sequences
which occur in the byte stream. A non-modal complex encoding is one in which
characters are encoded using variable numbers of bytes. The number of bytes
used to encode a character depends on the value of the initial byte.</p>
<p>Defined in <code>CnvUtilities</code>:
<br><code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aConvertFromIntermediateBufferInPlace%28%29" title="Inserts an escape sequence into the descriptor">ConvertFromIntermediateBufferInPlace()</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aConvertFromUnicode%28%29" title="Converts Unicode text into a complex foreign character set encoding">ConvertFromUnicode()</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aConvertToUnicodeFromHeterogeneousForeign%28%29" title="Converts text from a non-modal complex character set encoding (e.g">ConvertToUnicodeFromHeterogeneousForeign()</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aConvertToUnicodeFromModalForeign%28%29" title="Converts text from a modal foreign character set encoding into Unicode">ConvertToUnicodeFromModalForeign()</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aFConvertFromIntermediateBufferInPlace" title="A pointer to a function which "mangles" text when converting from Unicode into a complex modal or non-modal foreign character set encoding">FConvertFromIntermediateBufferInPlace</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aFConvertToIntermediateBufferInPlace" title="A pointer to a function which prepares the text for conversion into Unicode">FConvertToIntermediateBufferInPlace</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aFNumberOfBytesAbleToConvert" title="A pointer to a function which calculates the number of consecutive bytes in the remainder of the foreign descriptor which can be converted using the current character set's conversion data">FNumberOfBytesAbleToConvert</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSCharacterSet" title="Character conversion data for one of the character sets which is specified in a complex character set encoding">SCharacterSet</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSMethod" title="Character conversion data for one of the character sets which is specified in a non-modal complex character set encoding">SMethod</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSState" title="Character conversion data for one of the character sets which is specified in a modal character set encoding">SState</a></code>
</p>
<a name="2.5"></a>
</div><div class="Head2">
<hr size="2" noshade>
<h2>Convert from Unicode to complex foreign</h2>
</div><div class="Bodytext">
<a name="2.5.2"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertFromUnicode%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertFromUnicode()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt ConvertFromUnicode(CCnvCharacterSetConverter::TEndianness aDefaultEndiannessOfForeignCharacters, const TDesC8&amp; aReplacementForUnconvertibleUnicodeCharacters, TDes8&amp; aForeign, const TDesC16&amp; aUnicode, CCnvCharacterSetConverter::TArrayOfAscendingIndices&amp; aIndicesOfUnconvertibleCharacters, const TArray&lt;SCharacterSet&gt;&amp; aArrayOfCharacterSets);</code></p><h4 class="subheading">Description</h4>
<p>Converts Unicode text into a complex foreign character set
encoding. This is an encoding which cannot be converted simply by calling
<code>CCnvCharacterSetConverter::DoConvertFromUnicode()</code>. It may be modal
(e.g. JIS) or non-modal (e.g. Shift-JIS).</p>
<p>The Unicode text specified in <code>aUnicode</code> is
converted using the array of conversion data objects
(<code>aArrayOfCharacterSets</code>) provided by the plug-in for the complex
character set encoding, and the converted text is returned in
<code>aForeign</code>. Any existing contents in <code>aForeign</code> are
overwritten.</p>
<p>Unlike
<code>CCnvCharacterSetConverter::DoConvertFromUnicode()</code>, multiple
character sets can be specified. <code>aUnicode</code> is converted using the
first character conversion data object in the array. When a character is found
which cannot be converted using that data, each character set in the array is
tried in turn. If it cannot be converted using any object in the array, the
index of the character is appended to
<code>aIndicesOfUnconvertibleCharacters</code> and the character is replaced by
<code>aReplacementForUnconvertibleUnicodeCharacters</code>.</p>
<p>If it can be converted using another object in the array, that
object is used to convert all subsequent characters until another unconvertible
character is found.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TEndianness
aDefaultEndiannessOfForeignCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The default endian-ness to use when writing the characters in
the foreign character set. If an endian-ness for foreign characters is
specified in the current conversion data object, then that is used instead and
the value of <code>aDefaultEndiannessOfForeignCharacters</code> is ignored.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp;
aReplacementForUnconvertibleUnicodeCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The single character (one or more byte values) which is used
to replace unconvertible characters. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes8&amp; aForeign </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the converted text&#0160;in the
non-Unicode character set. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC16&amp; aUnicode </code></td>
<td class="Cell"><p class="ValueDesc"> The source Unicode text to be converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TArrayOfAscendingIndices&amp;
aIndicesOfUnconvertibleCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> On return, holds an ascending array of the indices of each
Unicode character in the source text which could not be converted (because none
of the target character sets have an equivalent character). </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TArray&lt;SCharacterSet&gt;&amp; aArrayOfCharacterSets
</code></td>
<td class="Cell"><p class="ValueDesc"> Array of character conversion data objects, representing the
character sets which comprise a complex character set encoding. These are used
in sequence to convert the Unicode text. There must be at least one character
set in this array and no character set may have any NULL member data, or a
panic occurs. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of unconverted characters left at the end of the
input descriptor (e.g. because <code>aForeign</code> was not long enough to
hold all the text), or a negative error value, as defined in
<code>CCnvCharacterSetConverter::TError</code>. </p></td>
</tr>
</table></td></tr></table>
<a name="2.5.3"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertFromUnicode%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertFromUnicode()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt ConvertFromUnicode(CCnvCharacterSetConverter::TEndianness aDefaultEndiannessOfForeignCharacters, const TDesC8&amp; aReplacementForUnconvertibleUnicodeCharacters, TDes8&amp; aForeign, const TDesC16&amp; aUnicode, CCnvCharacterSetConverter::TArrayOfAscendingIndices&amp; aIndicesOfUnconvertibleCharacters, const TArray&lt;SCharacterSet&gt;&amp; aArrayOfCharacterSets, TUint&amp; aOutputConversionFlags, TUint aInputConversionFlags);</code></p><h4 class="subheading">Description</h4>
<p>Converts Unicode text into a complex foreign character set
encoding. This is an encoding which cannot be converted simply by a call to
<code>CCnvCharacterSetConverter::DoConvertFromUnicode()</code>. It may be modal
(e.g. JIS) or non-modal (e.g. Shift-JIS).</p>
<p>The Unicode text specified in <code>aUnicode</code> is
converted using the array of conversion data objects
(<code>aArrayOfCharacterSets</code>) provided by the plug-in for the complex
character set encoding and the converted text is returned in
<code>aForeign</code>. The function can either append to <code>aForeign</code>
or overwrite its contents (if any).</p>
<p>Unlike
<code>CCnvCharacterSetConverter::DoConvertFromUnicode()</code>, multiple
character sets can be specified. <code>aUnicode</code> is converted using the
first character conversion data object in the array. When a character is found
which cannot be converted using that data, each character set in the array is
tried in turn. If it cannot be converted using any object in the array, the
index of the character is appended to
<code>aIndicesOfUnconvertibleCharacters</code> and the character is replaced by
<code>aReplacementForUnconvertibleUnicodeCharacters</code>.</p>
<p>If it can be converted using another object in the array, that
object is used to convert all subsequent characters until another unconvertible
character is found.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TEndianness
aDefaultEndiannessOfForeignCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The default endian-ness to use when writing the characters in
the foreign character set. If an endian-ness for foreign characters is
specified in the current conversion data object, then that is used instead and
the value of <code>aDefaultEndiannessOfForeignCharacters</code> is ignored.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp;
aReplacementForUnconvertibleUnicodeCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The single character (one or more byte values) which is used
to replace unconvertible characters. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes8&amp; aForeign </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the converted text&#0160;in the
non-Unicode character set. This may already contain some text. If it does, and
if <code>aInputConversionFlags</code> specifies
<code>EInputConversionFlagAppend</code>, then the converted text is appended to
this descriptor. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC16&amp; aUnicode </code></td>
<td class="Cell"><p class="ValueDesc"> The source Unicode text to be converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TArrayOfAscendingIndices&amp;
aIndicesOfUnconvertibleCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> On return, holds an ascending array of the indices of each
Unicode character in the source text which could not be converted (because none
of the target character sets have an equivalent character). </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TArray&lt;SCharacterSet&gt;&amp; aArrayOfCharacterSets
</code></td>
<td class="Cell"><p class="ValueDesc"> Array of character set data objects. These are used in
sequence to convert the Unicode text. There must be at least one character set
in this array and no character set may have any NULL member data, or a panic
occurs. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint&amp; aOutputConversionFlags </code></td>
<td class="Cell"><p class="ValueDesc"> If the input descriptor ended in a truncated sequence, e.g.
the first half only of a Unicode surrogate pair, this returns with the
<code>EOutputConversionFlagInputIsTruncated</code> flag set. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint aInputConversionFlags </code></td>
<td class="Cell"><p class="ValueDesc"> Specify
<code>CCnvCharacterSetConverter::EInputConversionFlagAppend</code> to append
the text to <code>aForeign</code>. Specify
<code>CCnvCharacterSetConverter::EInputConversionFlagAllowTruncatedInputNotEvenPartlyConsumable</code>
to prevent the function from returning the error-code
<code>EErrorIllFormedInput</code> when the input descriptor consists of nothing
but a truncated sequence. The
<code>CCnvCharacterSetConverter::EInputConversionFlagStopAtFirstUnconvertibleCharacter</code>
flag must not be set, otherwise a panic occurs. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of unconverted characters left at the end of the
input descriptor (e.g. because <code>aForeign</code> was not long enough to
hold all the text), or a negative error value, as defined in
<code>CCnvCharacterSetConverter::TError</code>. </p></td>
</tr>
</table></td></tr></table>
<a name="2.5.4"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertFromIntermediateBufferInPlace%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertFromIntermediateBufferInPlace()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static void ConvertFromIntermediateBufferInPlace(TInt aStartPositionInDescriptor, TDes8&amp; aDescriptor, TInt&amp; aNumberOfCharactersThatDroppedOut, const TDesC8&amp; aEscapeSequence, TInt aNumberOfBytesPerCharacter);</code></p><h4 class="subheading">Description</h4>
<p>Inserts an escape sequence into the descriptor.</p>
<p>This function is provided to help in the implementation of
<code>ConvertFromUnicode()</code> for modal character set encodings. Each
<code>SCharacterSet</code> object in the array passed to
<code>ConvertFromUnicode()</code> must have its
<code>iConvertFromIntermediateBufferInPlace</code> member assigned. To do this
for a modal character set encoding, implement a function whose signature
matches that of <code>FConvertFromIntermediateBufferInPlace</code> and which
calls this function, passing all arguments unchanged, and specifying the
character set's escape sequence and the number of bytes per character.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aStartPositionInDescriptor </code></td>
<td class="Cell"><p class="ValueDesc"> The byte position in <code>aDescriptor</code> at which the
escape sequence is inserted. If the character set uses more than one byte per
character, this position must be the start of a character, otherwise a panic
occurs. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes8&amp; aDescriptor </code></td>
<td class="Cell"><p class="ValueDesc"> The descriptor into which the escape sequence is inserted.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aNumberOfCharactersThatDroppedOut </code></td>
<td class="Cell"><p class="ValueDesc"> The escape sequence is inserted into the start of
<code>aDescriptor</code> and any characters that need to drop out to make room
for the escape sequence (because the descriptor's maximum length was not long
enough) drop out from the end of the buffer. This parameter indicates the
number of characters that needed to drop out.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aEscapeSequence </code></td>
<td class="Cell"><p class="ValueDesc"> The escape sequence for the character set. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aNumberOfBytesPerCharacter </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes per character. </p></td>
</tr>
</table></td></tr></table>
<a name="2.6"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Convert to Unicode from complex foreign</h2>
</div><div class="Bodytext">
<a name="2.6.2"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertToUnicodeFromModalForeign%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertToUnicodeFromModalForeign()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt ConvertToUnicodeFromModalForeign(CCnvCharacterSetConverter::TEndianness aDefaultEndiannessOfForeignCharacters, TDes16&amp; aUnicode, const TDesC8&amp; aForeign, TInt&amp; aState, TInt&amp; aNumberOfUnconvertibleCharacters, TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter, const TArray&lt;SState&gt;&amp; aArrayOfStates);</code></p><h4 class="subheading">Description</h4>
<p>Converts text from a modal foreign character set encoding into
Unicode.</p>
<p>The non-Unicode text specified in <code>aForeign</code> is
converted using the array of character set conversion objects
(<code>aArrayOfStates</code>) provided by the plug-in, and the converted text
is returned in <code>aUnicode</code>. Overwrites the contents, if any, of
<code>aUnicode</code>. The first element in <code>aArrayOfStates</code> is
taken to be the default mode (i.e. the mode to assume by default if there is no
preceding escape sequence).</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TEndianness
aDefaultEndiannessOfForeignCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The default endian-ness of the foreign characters. If an
endian-ness for foreign characters is specified in the conversion data, then
that is used instead and the value of
<code>aDefaultEndiannessOfForeignCharacters</code> is ignored. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes16&amp; aUnicode </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the text converted into Unicode. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aForeign </code></td>
<td class="Cell"><p class="ValueDesc"> The non-Unicode source text to be converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aState </code></td>
<td class="Cell"><p class="ValueDesc"> Used to store a modal character set encoding's current mode
across multiple calls to <code>ConvertToUnicode()</code> on the same input
descriptor. This argument should be passed the same object as passed to the
plug-in's <code>ConvertToUnicode()</code> exported function.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aNumberOfUnconvertibleCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the number of characters in
<code>aForeign</code> which were not converted. Characters which cannot be
converted are output as Unicode replacement characters (0xfffd). </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter
</code></td>
<td class="Cell"><p class="ValueDesc"> On return, the index of the first byte of the first
unconvertible character. For instance if the first character in the input
descriptor (<code>aForeign</code>) could not be converted, then this parameter
is set to the first byte of that character, i.e. zero. A negative value is
returned if all the characters were converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TArray&lt;SState&gt;&amp; aArrayOfStates </code></td>
<td class="Cell"><p class="ValueDesc"> Array of character set conversion data objects, and their
escape sequences ("modes"). There must be one or more modes in this array, none
of the modes can have any NULL member data, and each mode's escape sequence
must begin with <code>KControlCharacterEscape</code> (0x1b) or a panic occurs.
</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of unconverted bytes left at the end of the input
descriptor, or a negative error value, as defined in <code>TError</code>.
</p></td>
</tr>
</table></td></tr></table>
<a name="2.6.3"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertToUnicodeFromModalForeign%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertToUnicodeFromModalForeign()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt ConvertToUnicodeFromModalForeign(CCnvCharacterSetConverter::TEndianness aDefaultEndiannessOfForeignCharacters, TDes16&amp; aUnicode, const TDesC8&amp; aForeign, TInt&amp; aState, TInt&amp; aNumberOfUnconvertibleCharacters, TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter, const TArray&lt;SState&gt;&amp; aArrayOfStates, TUint&amp; aOutputConversionFlags, TUint aInputConversionFlags);</code></p><h4 class="subheading">Description</h4>
<p>Converts text from a modal foreign character set encoding into
Unicode.</p>
<p>The non-Unicode text specified in <code>aForeign</code> is
converted using the array of character set conversion objects
(<code>aArrayOfStates</code>) provided by the plug-in, and the converted text
is returned in <code>aUnicode</code>. The function can either append to
<code>aUnicode</code> or overwrite its contents (if any), depending on the
input conversion flags specified. The first element in
<code>aArrayOfStates</code> is taken to be the default mode (i.e. the mode to
assume by default if there is no preceding escape sequence).</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TEndianness
aDefaultEndiannessOfForeignCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The default endian-ness for the foreign characters. If an
endian-ness for foreign characters is specified in the conversion data, then
that is used instead and the value of
<code>aDefaultEndiannessOfForeignCharacters</code> is ignored. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes16&amp; aUnicode </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the text converted into Unicode. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aForeign </code></td>
<td class="Cell"><p class="ValueDesc"> The non-Unicode source text to be converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aState </code></td>
<td class="Cell"><p class="ValueDesc"> Used to store a modal character set encoding's current mode
across multiple calls to <code>ConvertToUnicode()</code> on the same input
descriptor. This argument should be passed the same object as passed to the
plug-in's <code>ConvertToUnicode()</code> exported function. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aNumberOfUnconvertibleCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the number of characters in
<code>aForeign</code> which were not converted. Characters which cannot be
converted are output as Unicode replacement characters (0xfffd). </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter
</code></td>
<td class="Cell"><p class="ValueDesc"> On return, the index of the first byte of the first
unconvertible character. For instance if the first character in the input
descriptor (<code>aForeign</code>) could not be converted, then this parameter
is set to the first byte of that character, i.e. zero. A negative value is
returned if all the characters were converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TArray&lt;SState&gt;&amp; aArrayOfStates </code></td>
<td class="Cell"><p class="ValueDesc"> Array of character set conversion data objects, and their
escape sequences. There must be one or more modes in this array, none of the
modes can have any NULL member data, and each mode's escape sequence must begin
with <code>KControlCharacterEscape</code> (0x1b) or a panic occurs. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint&amp; aOutputConversionFlags </code></td>
<td class="Cell"><p class="ValueDesc"> If the input descriptor ended in a truncated sequence, e.g. an
incomplete multi-byte character, <code>aOutputConversionFlags</code> returns
with the <code>EOutputConversionFlagInputIsTruncated</code> flag set. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint aInputConversionFlags </code></td>
<td class="Cell"><p class="ValueDesc"> Specify
<code>CCnvCharacterSetConverter::EInputConversionFlagAppend</code> to append
the text to <code>aUnicode</code>. Specify
<code>EInputConversionFlagAllowTruncatedInputNotEvenPartlyConsumable</code> to
prevent the function from returning the error-code
<code>EErrorIllFormedInput</code> when the input descriptor consists of nothing
but a truncated sequence. The
<code>CCnvCharacterSetConverter::EInputConversionFlagStopAtFirstUnconvertibleCharacter</code>
flag must not be set, otherwise a panic occurs. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of unconverted bytes left at the end of the input
descriptor, or a negative error value, as defined in <code>TError</code>.
</p></td>
</tr>
</table></td></tr></table>
<a name="2.6.4"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertToUnicodeFromHeterogeneousForeign%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertToUnicodeFromHeterogeneousForeign()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt ConvertToUnicodeFromHeterogeneousForeign(CCnvCharacterSetConverter::TEndianness aDefaultEndiannessOfForeignCharacters, TDes16&amp; aUnicode, const TDesC8&amp; aForeign, TInt&amp; aNumberOfUnconvertibleCharacters, TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter, const TArray&lt;SMethod&gt;&amp; aArrayOfMethods);</code></p><h4 class="subheading">Description</h4>
<p>Converts text from a non-modal complex character set encoding
(e.g. Shift-JIS or EUC-JP) into Unicode.</p>
<p>The non-Unicode text specified in <code>aForeign</code> is
converted using the array of character set conversion methods
(<code>aArrayOfMethods</code>) provided by the plug-in, and the converted text
is returned in <code>aUnicode</code>. Overwrites the contents, if any, of
<code>aUnicode</code>.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TEndianness
aDefaultEndiannessOfForeignCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The default endian-ness of the foreign characters. If an
endian-ness for foreign characters is specified in the conversion data, then
that is used instead and the value of
<code>aDefaultEndiannessOfForeignCharacters</code> is ignored. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes16&amp; aUnicode </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the text converted into Unicode. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aForeign </code></td>
<td class="Cell"><p class="ValueDesc"> The non-Unicode source text to be converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aNumberOfUnconvertibleCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the number of characters in
<code>aForeign</code> which were not converted. Characters which cannot be
converted are output as Unicode replacement characters (0xfffd). </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter
</code></td>
<td class="Cell"><p class="ValueDesc"> On return, the index of the first byte of the first
unconvertible character. For instance if the first character in the input
descriptor (<code>aForeign</code>) could not be converted, then this parameter
is set to the first byte of that character, i.e. zero. A negative value is
returned if all the characters were converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TArray&lt;SMethod&gt;&amp; aArrayOfMethods </code></td>
<td class="Cell"><p class="ValueDesc"> Array of conversion methods. There must be one or more methods
in this array and none of the methods in the array can have any NULL member
data or a panic occurs. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of unconverted bytes left at the end of the input
descriptor, or a negative error value, as defined in <code>TError</code>.
</p></td>
</tr>
</table></td></tr></table>
<a name="2.6.5"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aConvertToUnicodeFromHeterogeneousForeign%28%29"></a>
<hr size="1" noshade>
<h3><code>ConvertToUnicodeFromHeterogeneousForeign()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt ConvertToUnicodeFromHeterogeneousForeign(CCnvCharacterSetConverter::TEndianness aDefaultEndiannessOfForeignCharacters, TDes16&amp; aUnicode, const TDesC8&amp; aForeign, TInt&amp; aNumberOfUnconvertibleCharacters, TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter, const TArray&lt;SMethod&gt;&amp; aArrayOfMethods, TUint&amp; aOutputConversionFlags, TUint aInputConversionFlags);</code></p><h4 class="subheading">Description</h4>
<p>Converts text from a non-modal complex character set encoding
(e.g. Shift-JIS, or EUC-JP) into Unicode.</p>
<p>The non-Unicode text specified in <code>aForeign</code> is
converted using the array of character set conversion methods
(<code>aArrayOfMethods</code>) provided by the plug-in, and the converted text
is returned in <code>aUnicode</code>. The function can either be set to append
to <code>aUnicode</code>, or overwrite its contents.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> CCnvCharacterSetConverter::TEndianness
aDefaultEndiannessOfForeignCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> The default endian-ness for the foreign characters. If an
endian-ness for foreign characters is specified in the conversion data, then
that is used instead and the value of
<code>aDefaultEndiannessOfForeignCharacters</code> is ignored. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes16&amp; aUnicode </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the text converted into Unicode. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aForeign </code></td>
<td class="Cell"><p class="ValueDesc"> The non-Unicode source text to be converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aNumberOfUnconvertibleCharacters </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the number of characters in
<code>aForeign</code> which were not converted. Characters which cannot be
converted are output as Unicode replacement characters (0xfffd). </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt&amp; aIndexOfFirstByteOfFirstUnconvertibleCharacter
</code></td>
<td class="Cell"><p class="ValueDesc"> On return, the index of the first byte of the first
unconvertible character. For instance if the first character in the input
descriptor (<code>aForeign</code>) could not be converted, then this parameter
is set to the first byte of that character, i.e. zero. A negative value is
returned if all the characters were converted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TArray&lt;SMethod&gt;&amp; aArrayOfMethods </code></td>
<td class="Cell"><p class="ValueDesc"> Array of conversion methods. There must be one or more methods
in this array and none of the methods in the array can have any NULL member
data or a panic occurs. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint&amp; aOutputConversionFlags </code></td>
<td class="Cell"><p class="ValueDesc"> If the input descriptor ended in a truncated sequence, e.g. an
incomplete multi-byte character, <code>aOutputConversionFlags</code> returns
with the <code>EOutputConversionFlagInputIsTruncated</code> flag set. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint aInputConversionFlags </code></td>
<td class="Cell"><p class="ValueDesc"> Specify
<code>CCnvCharacterSetConverter::EInputConversionFlagAppend</code> to append
the text to <code>aUnicode</code>. Specify
<code>EInputConversionFlagAllowTruncatedInputNotEvenPartlyConsumable</code> to
prevent the function from returning the error-code
<code>EErrorIllFormedInput</code> when the input descriptor consists of nothing
but a truncated sequence. The
<code>CCnvCharacterSetConverter::EInputConversionFlagStopAtFirstUnconvertibleCharacter</code>
flag must not be set, otherwise a panic occurs. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of unconverted bytes left at the end of the input
descriptor, or a negative error value, as defined in <code>TError</code>.
</p></td>
</tr>
</table></td></tr></table>
<a name="2.7"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Structs</h2>
</div><div class="Bodytext">
<a name="2.7.2"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aSCharacterSet"></a>
<hr size="1" noshade>
<h3>Struct <code>SCharacterSet</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>SCharacterSet</code></p><h4 class="subheading">Description</h4>
<p>Character conversion data for one of the character sets which
is specified in a complex character set encoding. An array of these structs is
used when converting from Unicode to a complex character set encoding (see
<code>CnvUtilities::ConvertFromUnicode()</code>). None of the members may be
NULL.</p>
<p>Defined in <code>CnvUtilities::SCharacterSet</code>:
<br><code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSCharacterSet%3a%3aiConversionData" title="The conversion data">iConversionData</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSCharacterSet%3a%3aiConvertFromIntermediateBufferInPlace" title="A pointer to a function which "mangles" the text in a way appropriate to the target complex character set">iConvertFromIntermediateBufferInPlace</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSCharacterSet%3a%3aiEscapeSequence" title="The escape sequence which introduces the character set, i.e">iEscapeSequence</a></code>
</p>
<a name="2.7.2.4"></a><a name="%3a%3aCnvUtilities%3a%3aSCharacterSet%3a%3aiConversionData"></a>
<h4><code>iConversionData</code></h4><hr size="8" noshade>
<p class="Prototype"><code>const SCnvConversionData* iConversionData</code></p><h4 class="subheading">Description</h4>
<p>The conversion data.</p>
<a name="2.7.2.5"></a><a name="%3a%3aCnvUtilities%3a%3aSCharacterSet%3a%3aiConvertFromIntermediateBufferInPlace"></a>
<h4><code>iConvertFromIntermediateBufferInPlace</code></h4><hr size="8" noshade>
<p class="Prototype"><code>FConvertFromIntermediateBufferInPlace iConvertFromIntermediateBufferInPlace</code></p><h4 class="subheading">Description</h4>
<p>A pointer to a function which &quot;mangles&quot; the text in a way
appropriate to the target complex character set. For instance it might insert a
shifting character, escape sequence, or other special characters.</p>
<a name="2.7.2.6"></a><a name="%3a%3aCnvUtilities%3a%3aSCharacterSet%3a%3aiEscapeSequence"></a>
<h4><code>iEscapeSequence</code></h4><hr size="8" noshade>
<p class="Prototype"><code>const TDesC8* iEscapeSequence</code></p><h4 class="subheading">Description</h4>
<p>The escape sequence which introduces the character set, i.e.
it identifies this character set as the next one to use. Must not be NULL. If
the character set is non-modal, this should be set to an empty
descriptor.</p>
<a name="2.7.3"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aSState"></a>
<hr size="1" noshade>
<h3>Struct <code>SState</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>SState</code></p><h4 class="subheading">Description</h4>
<p>Character conversion data for one of the character sets which
is specified in a modal character set encoding. An array of these structs is
used when converting from a modal character set into Unicode, using
<code>CnvUtilities::ConvertToUnicodeFromModalForeign()</code>. Neither of the
members may be NULL.</p><p>Defined in <code>CnvUtilities::SState</code>:
<br><code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSState%3a%3aiConversionData" title="The conversion data">iConversionData</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSState%3a%3aiEscapeSequence" title="The escape sequence which introduces the character set, i.e">iEscapeSequence</a></code>
</p>
<a name="2.7.3.4"></a><a name="%3a%3aCnvUtilities%3a%3aSState%3a%3aiEscapeSequence"></a>
<h4><code>iEscapeSequence</code></h4><hr size="8" noshade>
<p class="Prototype"><code>const TDesC8* iEscapeSequence</code></p><h4 class="subheading">Description</h4>
<p>The escape sequence which introduces the character set, i.e.
it identifies this character set as the next one to use. This must begin with
<code>KControlCharacterEscape</code>. </p>
<a name="2.7.3.5"></a><a name="%3a%3aCnvUtilities%3a%3aSState%3a%3aiConversionData"></a>
<h4><code>iConversionData</code></h4><hr size="8" noshade>
<p class="Prototype"><code>const SCnvConversionData* iConversionData</code></p><h4 class="subheading">Description</h4>
<p>The conversion data.</p>
<a name="2.7.4"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aSMethod"></a>
<hr size="1" noshade>
<h3>Struct <code>SMethod</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>SMethod</code></p><h4 class="subheading">Description</h4>
<p>Character conversion data for one of the character sets which
is specified in a non-modal complex character set encoding. An array of these
structs is used when converting from a non-modal complex character set encoding
into Unicode using
<code>CnvUtilities::ConvertToUnicodeFromHeterogeneousForeign()</code>. None of
the members may be NULL.</p>
<p>Defined in <code>CnvUtilities::SMethod</code>:
<br><code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiConversionData" title="The conversion data">iConversionData</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiConvertToIntermediateBufferInPlace" title="A pointer to a function which prepares the text for conversion into Unicode">iConvertToIntermediateBufferInPlace</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiNumberOfBytesAbleToConvert" title="A pointer to a function which calculates the number of consecutive bytes in the remainder of the foreign descriptor which can be converted using the current character set's conversion data">iNumberOfBytesAbleToConvert</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiNumberOfBytesPerCharacter" title="The number of bytes per character">iNumberOfBytesPerCharacter</a></code>, <code class="ApiItem"><a href="CnvUtilitiesClass.html#%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiNumberOfCoreBytesPerCharacter" title="The number of core bytes per character">iNumberOfCoreBytesPerCharacter</a></code>
</p>
<a name="2.7.4.4"></a><a name="%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiNumberOfBytesAbleToConvert"></a>
<h4><code>iNumberOfBytesAbleToConvert</code></h4><hr size="8" noshade>
<p class="Prototype"><code>FNumberOfBytesAbleToConvert iNumberOfBytesAbleToConvert</code></p><h4 class="subheading">Description</h4>
<p>A pointer to a function which calculates the number of
consecutive bytes in the remainder of the foreign descriptor which can be
converted using the current character set's conversion data. It may return a
negative <code>CCnvCharacterSetConverter::TError</code> value to indicate an
error in the encoding.</p>
<a name="2.7.4.5"></a><a name="%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiConvertToIntermediateBufferInPlace"></a>
<h4><code>iConvertToIntermediateBufferInPlace</code></h4><hr size="8" noshade>
<p class="Prototype"><code>FConvertToIntermediateBufferInPlace iConvertToIntermediateBufferInPlace</code></p><h4 class="subheading">Description</h4>
<p>A pointer to a function which prepares the text for
conversion into Unicode. For instance it might remove any shifting or other
special characters.</p>
<a name="2.7.4.6"></a><a name="%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiConversionData"></a>
<h4><code>iConversionData</code></h4><hr size="8" noshade>
<p class="Prototype"><code>const SCnvConversionData* iConversionData</code></p><h4 class="subheading">Description</h4>
<p>The conversion data.</p>
<a name="2.7.4.7"></a><a name="%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiNumberOfBytesPerCharacter"></a>
<h4><code>iNumberOfBytesPerCharacter</code></h4><hr size="8" noshade>
<p class="Prototype"><code>TInt16 iNumberOfBytesPerCharacter</code></p><h4 class="subheading">Description</h4>
<p>The number of bytes per character.</p>
<a name="2.7.4.8"></a><a name="%3a%3aCnvUtilities%3a%3aSMethod%3a%3aiNumberOfCoreBytesPerCharacter"></a>
<h4><code>iNumberOfCoreBytesPerCharacter</code></h4><hr size="8" noshade>
<p class="Prototype"><code>TInt16 iNumberOfCoreBytesPerCharacter</code></p><h4 class="subheading">Description</h4>
<p>The number of core bytes per character.</p>
<a name="2.8"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Typedefs</h2>
</div><div class="Bodytext">
<a name="2.8.2"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aFConvertFromIntermediateBufferInPlace"></a>
<hr size="1" noshade>
<h3>Typedef <code>FConvertFromIntermediateBufferInPlace</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>typedef void (*FConvertFromIntermediateBufferInPlace)(TInt aStartPositionInDescriptor, TDes8&amp; aDescriptor, TInt&amp; aNumberOfCharactersThatDroppedOut);</code></p><h4 class="subheading">Description</h4>
<p>A pointer to a function which &quot;mangles&quot; text when converting
from Unicode into a complex modal or non-modal foreign character set encoding.
It might insert a shifting character, escape sequence, or other special
characters.</p>
<p>If the target character set encoding is modal, the
implementation of this function may call the
<code>CnvUtilities::ConvertFromIntermediateBufferInPlace()</code> utility
function which is provided because many modal character sets require an
identical implementation of this function.</p>
<a name="2.8.3"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aFNumberOfBytesAbleToConvert"></a>
<hr size="1" noshade>
<h3>Typedef <code>FNumberOfBytesAbleToConvert</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>typedef TInt (*FNumberOfBytesAbleToConvert)(const TDesC8&amp; aDescriptor);</code></p><h4 class="subheading">Description</h4>
<p>A pointer to a function which calculates the number of
consecutive bytes in the remainder of the foreign descriptor which can be
converted using the current character set's conversion data. Called when
converting from a non-modal complex character set encoding into Unicode. It may
return a negative <code>CCnvCharacterSetConverter::TError</code> value to
indicate an error in the encoding.</p>
<a name="2.8.4"></a></div><div class="Head3">
<a name="%3a%3aCnvUtilities%3a%3aFConvertToIntermediateBufferInPlace"></a>
<hr size="1" noshade>
<h3>Typedef <code>FConvertToIntermediateBufferInPlace</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>typedef void (*FConvertToIntermediateBufferInPlace)(TDes8&amp; aDescriptor);</code></p><h4 class="subheading">Description</h4>
<p>A pointer to a function which prepares the text for conversion
into Unicode. For instance it might remove any shifting or other special
characters. Called when converting from a non-modal complex character set
encoding into Unicode.</p>

</div><div class="Footer">
<hr noshade size="1">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td><p class="copyrightStatement">Copyright &copy;2002&nbsp; Symbian Ltd. &nbsp; &nbsp; &nbsp;	6.1-00174
</p></td>
<td align="right"><p><a href="#_top"><img
alt="[Top]" src="../../../stock/arrow_up.gif" border="0"
align="bottom"></a></p></td>
</table>
</div>
</body>
</html>
