<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>CCoeControl</title>
<link href="../../../stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css" media="screen"><!--
.ButtonBox { background-image: url(../../../stock/gradient.jpg); }
--></style>
</head>
<body><a name="_top"></a><a name="2"></a>
<table width="100%" border="0" cellspacing="0"
cellpadding="0"><tbody><tr><td colspan=2 class="LogoBox"><a><img
src="../../../stock/symbian.gif" alt="Symbian" width="121"
height="46" border="0"></a><img src="../../../stock/mainheading.gif"
alt=" Developer Library" height="46" width="183"></td></tr><tr><td
class="DocSetBox" width="33%">
<p><a href="../../../Product/Generic/index.html">SYMBIAN OS V6.1 EDITION FOR C++</a></p>
</td><td class="ButtonBox" align="right" width="67%">
<p><a href="../../../index/index.html"><img
src="../../../stock/btn_index.gif" alt="[Index]" width="53"
height="22" border="0"></a> <a href="../../GlobalGlossary/index.html"><img src="../../../stock/btn_glossary.gif"
alt="[Glossary]" border="0" width="81" height="22"></a> <img src="../../../stock/btn_spacer.gif"
alt="" width="60" height="22"> <a href="CCoeBrushAndPenContextClass.html"><img src="../../../stock/btn_prev.gif"
alt="[Previous]" border="0" width="85" height="22"></a> <a href="CCoeEnvClass.html"><img src="../../../stock/btn_next.gif" alt="[Next]"
border="0" width="58" height="22"></a></p>
</td></tr></table>
<hr noshade size="1">
<p class="breadcrumbNav">&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/index.html">Symbian&nbsp;OS&nbsp;v6.1&nbsp;Edition&nbsp;for&nbsp;C++</a>&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/APIReference/index.html">API&nbsp;Reference</a>&nbsp;<span class="separator">&#187;</span>
<a href="index.html">UI&nbsp;Control&nbsp;Framework</a>&nbsp;<span class="separator">&#187;</span>
CCoeControl</p>

<hr noshade size="1">
<div class="AuthoredContent">

<p>Location:
<code>coecntrl.h</code>
<br>Link against: <code>cone.lib</code>
</p>
</div><div class="Head1">
<a name="%3a%3aCCoeControl"></a>

<h1>Class <code>CCoeControl</code></h1>
</div><div class="Bodytext"><p class="Prototype"><code>CCoeControl</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Control base class from which all other controls are derived.
</p>
<p>Note:</p>
<ul>
<li>
<p>In ER5u only, this class derived additionally from
<code>MCoeInputObserver</code>.</p>
</li>
</ul>
<h4 class="subheading">Derivation</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr><td class="Cell"><code><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase">CBase</a></code></td><td class="Cell">Base class for all classes to be instantiated on the heap</td>
</tr>
<tr><td class="Cell"><code>CCoeControl</code></td><td class="Cell">Control base class from which all other controls are derived</td>
</tr>
</table></td></tr></table>
<p>Defined in <code>CCoeControl</code>:
<br><code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aActivateGc%28%29" title="Activates the standard graphics context">ActivateGc()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aActivateL%28%29" title="Sets control as ready to be drawn">ActivateL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aBackedUpWindow%28%29" title="Gets the backed-up window owned by control">BackedUpWindow()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCCoeControl%28%29" title="Default C++ constructor">CCoeControl()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCapturesPointer%28%29" title="Tests if pointer capture is set for the control">CapturesPointer()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aClaimPointerGrab%28%29" title="Claims pointer grab from another control">ClaimPointerGrab()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCloseWindow%28%29" title="Closes window owned by this control">CloseWindow()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aComponentControl%28%29" title="Gets the specified component of a compound control">ComponentControl()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aConstructFromResourceL%28%29" title="Constructs controls from a resource file">ConstructFromResourceL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aControlContext%28%29" title="Gets the control context being used by this control">ControlContext()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aControlEnv%28%29" title="Gets the control environment object for this control">ControlEnv()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCopyControlContextFrom%28%29" title="Sets the control's context from another control">CopyControlContextFrom()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCountComponentControls%28%29" title="Gets the number of controls contained in a compound control">CountComponentControls()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCreateBackedUpWindowL%28%29" title="Create a control's window as a backed-up window, specifying the display mode">CreateBackedUpWindowL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aCreateWindowL%28%29" title="Creates a control's window — specifying its parent window group">CreateWindowL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aDeactivateGc%28%29" title="Deactivates the standard graphics context owned by the UI control framework">DeactivateGc()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aDraw%28%29" title="Draw a control — called by window server">Draw()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aDrawDeferred%28%29" title="Draws the control with low priority — called by application">DrawDeferred()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aDrawNow%28%29" title="Draws a control — called by an application or other code">DrawNow()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aDrawableWindow%28%29" title="Get control's associated drawable window">DrawableWindow()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aEnableDragEvents%28%29" title="Requests pointer drag events">EnableDragEvents()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aFocusChanged%28%29" title="Responds to focus changed">FocusChanged()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aGetColor%28%29" title="Gets the over-ridden physical colour">GetColor()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aGetColorUseListL%28%29" title="Gets the list of logical colours used to draw the control">GetColorUseListL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aGetHelpContext%28%29" title="Gets the control's help context">GetHelpContext()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aGrabbingComponent%28%29" title="Gets the component control which is grabbing the pointer">GrabbingComponent()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandleComponentControlsResourceChange%28%29" title="Handles a change to the resources in the components of a compound control">HandleComponentControlsResourceChange()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandlePointerBufferReadyL%28%29" title="Handle events in pointer buffer">HandlePointerBufferReadyL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandlePointerEventL%28%29" title="Handles pointer events">HandlePointerEventL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandleRedrawEvent%28%29" title="Handles redraw event">HandleRedrawEvent()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandleResourceChange%28%29" title="Handles a change to the control's resources">HandleResourceChange()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHasBorder%28%29" title="Tests if a control has a border">HasBorder()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIgnoreEventsUntilNextPointerUp%28%29" title="Sets control to ignore pointer events until next pointer up">IgnoreEventsUntilNextPointerUp()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIndex%28%29" title="Gets the index of a control that is a component of this control">Index()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aInputCapabilities%28%29" title="Gets the control's input capabilities">InputCapabilities()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsActivated%28%29" title="Tests if the control has been activated">IsActivated()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsBackedUp%28%29" title="Tests if the window owned by the control is a backed-up window">IsBackedUp()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsBeingDestroyed%28%29" title="Tests if the control is being destroyed">IsBeingDestroyed()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsBlank%28%29" title="Tests if the control is a blank">IsBlank()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsDimmed%28%29" title="Tests if control is dimmed">IsDimmed()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsFocused%28%29" title="Tests if the control has focus">IsFocused()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsNonFocusing%28%29" title="Tests if the control can receive focus">IsNonFocusing()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsReadyToDraw%28%29" title="Tests if the control is ready for drawing">IsReadyToDraw()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsVisible%28%29" title="Tests if the control is visible">IsVisible()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aMakeVisible%28%29" title="Sets this control as visible or invisible">MakeVisible()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aMinimumSize%28%29" title="Sets the control's minimum required size">MinimumSize()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aObserver%28%29" title="Gets the control's observer">Observer()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aOfferKeyEventL%28%29" title="Handles key events">OfferKeyEventL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aOverrideColorL%28%29" title="Overrides the control's colour setting, as specified in the application's colour scheme">OverrideColorL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aOwnsWindow%28%29" title="Tests if the control is window-owning">OwnsWindow()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aPosition%28%29" title="Gets the control's position">Position()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aPositionChanged%28%29" title="Responds to changes in the position of a control">PositionChanged()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aPositionRelativeToScreen%28%29" title="Gets the control's position relative to screen origin">PositionRelativeToScreen()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aPrepareForFocusGainL%28%29" title="Prepares the control for gaining focus">PrepareForFocusGainL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aPrepareForFocusLossL%28%29" title="Prepare for focus loss">PrepareForFocusLossL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aRect%28%29" title="Gets the control's extent">Rect()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aRecursivelyMergedInputCapabilities%28%29" title="Gets the input capabilities of the control and all its components">RecursivelyMergedInputCapabilities()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aReportEventL%28%29" title="Sends an event to the control's observer">ReportEventL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aResetGc%28%29" title="Resets the standard graphics context">ResetGc()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetAdjacent%28%29" title="Sets control's appearance when next to other controls">SetAdjacent()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetAllowStrayPointers%28%29" title="Set allow stray pointer events">SetAllowStrayPointers()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetBlank%28%29" title="Sets a flag to indicate the control is blank">SetBlank()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetCanDrawOutsideRect%28%29" title="Allows the control to draw outside its own extent">SetCanDrawOutsideRect()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetComponentsToInheritVisibility%28%29" title="Sets components to inherit visibility setting from their container control">SetComponentsToInheritVisibility()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetContainerWindow%28%29" title="Sets a component control's container window — if the container is a backed up window owning control">SetContainerWindow()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetContainerWindowL%28%29" title="Sets a component control's container — leaving">SetContainerWindowL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetControlContext%28%29" title="Set the control context for this control">SetControlContext()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetCornerAndSize%28%29" title="Sets the control's position by setting its screen alignment and size">SetCornerAndSize()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetCornerAndSizeL%28%29" title="Sets the control's position by setting its screen alignment and size">SetCornerAndSizeL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetDimmed%28%29" title="Sets control dimmed">SetDimmed()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetExtent%28%29" title="Sets the control's extent — specifying size and position">SetExtent()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetExtentL%28%29" title="Sets the control's extent — specifying size and position">SetExtentL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetExtentToWholeScreen%28%29" title="Sets the control's extent to the whole screen">SetExtentToWholeScreen()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetExtentToWholeScreenL%28%29" title="Sets the control's extent to the whole screen">SetExtentToWholeScreenL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetFocus%28%29" title="Sets that the control has keyboard focus">SetFocus()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetFocusing%28%29" title="Sets the control as able to receive keyboard focus">SetFocusing()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetGloballyCapturing%28%29" title="Sets the global pointer capture flag">SetGloballyCapturing()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetNeighbor%28%29" title="Sets associated control">SetNeighbor()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetNonFocusing%28%29" title="Deprecated">SetNonFocusing()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetObserver%28%29" title="Sets the control's observer">SetObserver()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetPointerCapture%28%29" title="Set pointer capture">SetPointerCapture()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetPosition%28%29" title="Sets the control's position">SetPosition()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetRect%28%29" title="Sets the control's extent — specifying a TRect">SetRect()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetRectL%28%29" title="Sets the control's extent — specifying a TRect">SetRectL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetSize%28%29" title="Sets the control's size">SetSize()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetSizeL%28%29" title="Sets the control's size">SetSizeL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetSizeWithoutNotification%28%29" title="Sets a control's size without calling SizeChanged()">SetSizeWithoutNotification()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetSizeWithoutNotificationL%28%29" title="Sets a control's size without calling SizeChangedL()">SetSizeWithoutNotificationL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSize%28%29" title="Gets the control's size">Size()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSizeChanged%28%29" title="Responds to size changes to sets the size and position of the contents of this control">SizeChanged()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSizeChangedL%28%29" title="Responds to size changes to sets the size and position of the contents of this control">SizeChangedL()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSystemGc%28%29" title="Gets the standard graphics context for use when drawing controls">SystemGc()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aWindow%28%29" title="Get control's associated window">Window()</a></code>, <code class="ApiItem"><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3a%7eCCoeControl%28%29" title="Destructor">~CCoeControl()</a></code>
</p>
<p>Inherited from <code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase" title="Base class for all classes to be instantiated on the heap">CBase</a></code>:
<br><code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase%3a%3aoperator%20new%28%29" title="Allocates the object from the heap and then initialises its contents to binary zeroes">operator new()</a></code></p>
<a name="2.6"></a>
</div><div class="Head2">
<hr size="2" noshade>
<h2>Construction and destruction</h2>
</div><div class="Bodytext">
<a name="2.6.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCCoeControl%28%29"></a>
<hr size="1" noshade>
<h3><code>CCoeControl()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>CCoeControl();</code></p><h4 class="subheading">Description</h4>
<p>Default C++ constructor. </p>
<p>This function performs initialisation of the
<code>CCoeControl</code> base class.</p>
<p>Note:</p>
<ul>
<li>
<p>The <code>CCoeControl</code> class is normally used as a
base class from which concrete control classes are derived. However, it can
also be instantiated as a concrete class: <code>CEikMsgWin</code> provides an
example of this.</p>
</li>
</ul>
<a name="2.6.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aConstructFromResourceL%28%29"></a>
<hr size="1" noshade>
<h3><code>ConstructFromResourceL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void ConstructFromResourceL(TResourceReader&amp; aReader);</code></p><h4 class="subheading">Description</h4>
<p>Constructs controls from a resource file. </p>
<p>This function has an empty default implementation. It should be
implemented if the control is to be displayed within a dialog. It should
initialise the control, reading in resource values from the resource file using
<code>aReader</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>If a control is not displayed in a dialog, it is necessary
to set the control's associated window using
<code>SetContainerWindowL()</code>. Since this may leave, the control should be
constructed using <code>ConstructL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TResourceReader&amp; aReader</code></td>
<td class="Cell"><p class="ValueDesc">The resource reader with which to access the control's resource
values.</p></td>
</tr>
</table></td></tr></table>
<a name="2.6.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsBeingDestroyed%28%29"></a>
<hr size="1" noshade>
<h3><code>IsBeingDestroyed()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool IsBeingDestroyed() const;</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Tests if the control is being destroyed.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control is being destroyed, otherwise
<code>EFalse</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.6.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3a%7eCCoeControl%28%29"></a>
<hr size="1" noshade>
<h3><code>~CCoeControl()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>~CCoeControl();</code></p><h4 class="subheading">Description</h4>
<p>Destructor. </p>
<p>It destroys the window owned by the control, if it is a
window-owning control.</p>
<p>From version 6.1, the destructor in debug builds checks if the
control exists in the control stack and gives a CONE 44 panic if it is still
there. An application must remove every control that it adds to the
stack.</p>
<a name="2.7"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Creating compound controls</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>A compound control is one which contains one or more simple or
compound controls. Compound controls are also known as container controls, and
may be window-owning or non-window-owning.</p>
<a name="2.7.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCountComponentControls%28%29"></a>
<hr size="1" noshade>
<h3><code>CountComponentControls()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TInt CountComponentControls() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the number of controls contained in a compound control.
</p>
<p>This function should be implemented by all compound
controls.</p>
<p>Note: </p>
<p>In 6.1 this was changed from protected to public.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt</code></td>
<td class="Cell"><p class="ValueDesc">The number of component controls contained by this
control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aComponentControl%28%29"></a>
<hr size="1" noshade>
<h3><code>ComponentControl()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual CCoeControl* ComponentControl(TInt aIndex) const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the specified component of a compound control. </p>
<p>This function should be implemented by all compound
controls.</p>
<p>Note:</p>
<ul>
<li>
<p>Within a compound control, each component control is
identified by an index, where the index depends on the order the controls were
added: the first is given an index of 0, the next an index of 1, and so
on.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt aIndex</code></td>
<td class="Cell"><p class="ValueDesc">The index of the control to get.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">CCoeControl*</code></td>
<td class="Cell"><p class="ValueDesc">The component control with an index of
<code>aIndex</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetContainerWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>SetContainerWindow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetContainerWindow(RWindow&amp; aWindow);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets a component control's container window — if the
container is a window-owning control.</p>
<p>This function sets the control's associated window to be the
same as the container's associated window.</p>
<p>The function can only be called on non-window-owning
controls.</p>
<p>Note:</p>
<ul>
<li>
<p>The container's window can be accessed using
<code>Window()</code>, <code>DrawableWindow()</code>, or
<code>BackedUpWindow()</code>.</p>
</li>
<li>
<p>This function is replaced by a leaving version after ER5:
<code>SetContainerWindowL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindow&amp; aWindow</code></td>
<td class="Cell"><p class="ValueDesc">The window owned by the container control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Panic codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If called on a window-owning control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.6"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetContainerWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetContainerWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetContainerWindowL(RWindow&amp; aWindow); </code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets a component control's container window — if the
container is a window-owning control. </p>
<p>This function sets the control's associated window to be the
same as the container's associated window. The function can only be called on
non-window-owning controls.</p>
<p>Note:</p>
<ul>
<li>
<p>The container's window can be accessed using
<code>Window()</code>, <code>DrawableWindow()</code>, or
<code>BackedUpWindow()</code>.</p>
</li>
<li>
<p>This function replaces <code>SetContainerWindow()</code>
used in ER5.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindow&amp; aWindow</code></td>
<td class="Cell"><p class="ValueDesc">The window owned by the container control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Panic codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If called on a window-owning control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.7"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetContainerWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>SetContainerWindow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetContainerWindow(RBackedUpWindow&amp; aWindow);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets a component control's container window — if the
container is a backed up window owning control. </p>
<p> This function sets the control's associated window to be the
same as the container's associated window.</p>
<p>The function can only be called on non-window-owning
controls.</p>
<p>Note:</p>
<ul>
<li>
<p>The container's window can be accessed using
<code>Window()</code>, <code>DrawableWindow()</code>, or
<code>BackedUpWindow()</code>.</p>
</li>
<li>
<p>This function is replaced by a leaving version after ER5:
<code>SetContainerWindowL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RBackedUpWindow&amp; aWindow</code></td>
<td class="Cell"><p class="ValueDesc">The backed up window owned by the control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Panic codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If called on a window-owning control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.8"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetContainerWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetContainerWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>SetContainerWindowL(RBackedUpWindow&amp; aWindow);</code></p><h4 class="subheading">Description</h4>
<p>Sets a component control's container window — if the
container is a backed up window owning control. </p>
<p>Sets a component control's container as a. This function sets
the control's associated window to be the same as the container's associated
window.</p>
<p>The function can only be called on non-window-owning controls.
</p>
<p>Note:</p>
<ul>
<li>
<p>The container's window can be accessed using
<code>Window()</code>, <code>DrawableWindow()</code>, or
<code>BackedUpWindow()</code>.</p>
</li>
<li>
<p>This function replaces <code>SetContainerWindow()</code>
used in ER5.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RBackedUpWindow&amp; aWindow</code></td>
<td class="Cell"><p class="ValueDesc">The backed up window owned by the control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Panic codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If called on a window-owning control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.9"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetContainerWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetContainerWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetContainerWindowL(const CCoeControl&amp; aContainer);</code></p><h4 class="subheading">Description</h4>
<p>Sets a component control's container — leaving. </p>
<p>It does this by setting the control's associated window to be
the same as the container's associated window.</p>
<p>This function can only be called on non-window-owning
controls.</p>
<p>Note:</p>
<ul>
<li>
<p>If the container is a window-owning control, you can
alternatively use <code>SetContainerWindow()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const CCoeControl&amp; aContainer</code></td>
<td class="Cell"><p class="ValueDesc">The compound control that is to be the container for this
control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Panic codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If called on a window-owning control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.10"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIndex%28%29"></a>
<hr size="1" noshade>
<h3><code>Index()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TInt Index(const CCoeControl* aControl) const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the index of a control that is a component of this
control.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const CCoeControl* aControl</code></td>
<td class="Cell"><p class="ValueDesc">The component control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt</code></td>
<td class="Cell"><p class="ValueDesc">The index of the component control within the compound control.
If <code>aControl</code> is not a component of this control, it returns
<code>KErrNotFound</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.11"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetAdjacent%28%29"></a>
<hr size="1" noshade>
<h3><code>SetAdjacent()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetAdjacent(TInt aAdjacent);</code></p><h4 class="subheading">Description</h4>
<p>Sets control's appearance when next to other controls. </p>
<p>Its intended use is to remove the double border that may occur
if two controls, both with borders, are adjacent within a container
control.</p>
<p>This function has an empty default implementation, and is not
used within the UI control framework. However, it may be implemented and used
by derived control classes: for example it is implemented and used by the
standard GUI. </p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt aAdjacent</code></td>
<td class="Cell"><p class="ValueDesc">Typically a value defined in <code>TGulAdjacent</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.12"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetNeighbor%28%29"></a>
<hr size="1" noshade>
<h3><code>SetNeighbor()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetNeighbor(CCoeControl* aNeighbor);</code></p><h4 class="subheading">Description</h4>
<p>Sets associated control. </p>
<p>This can be used to establish co-ordinated groups of controls
(e.g. in dialogs) without specific application co-operation.</p>
<p>This function has an empty default implementation, and is not
used within the UI control framework. However, it may be implemented and used
by derived control classes: for example it is implemented and used by the
standard GUI.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">CCoeControl* aNeighbor</code></td>
<td class="Cell"><p class="ValueDesc">A control to be used by this function.</p></td>
</tr>
</table></td></tr></table>
<a name="2.7.13"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aHasBorder%28%29"></a>
<hr size="1" noshade>
<h3><code>HasBorder()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TBool HasBorder() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if a control has a border.</p>
<p>When component controls are arranged in a container, the
container control may need to know whether or not the component have borders,
as this may affect the way the components are laid out within the
container.</p>
<p>The default implementation of this function always returns
<code>EFalse</code>, but can be overridden to provide the required
functionality. The GUI implements and uses this function in several of its
concrete controls.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control has a border,
<code>EFalse</code> if the control does not have a border. The default
implementation of this function always returns <code>EFalse</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Creating window owning controls</h2>
</div><div class="Bodytext">
<a name="2.8.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCreateWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>CreateWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CreateWindowL();</code></p><h4 class="subheading">Description</h4>
<p>Creates a control's window. The created window is the child of
the application's window group.</p>
<p>This function makes the specified control a window-owning
control, and would typically be called in the control's
<code>ConstructL()</code> function.</p>
<p>Note:</p>
<ul>
<li>
<p>The use of window owning controls is discouraged, as these
tax run-time resources. Ideally only the top level control in an appUi would be
window owning. There are some exceptions to this rule e.g. floating controls
like menus, dialogs and scroll bars.</p>
</li>
</ul>
<a name="2.8.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCreateWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>CreateWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CreateWindowL(const CCoeControl* aParent);</code></p><h4 class="subheading">Description</h4>
<p>Creates a control's window — specifying the parent control.
</p>
<p>The control's window is created as a child of the parent
control's window.</p>
<p>This function makes the specified control a window-owning
control, and would typically be called in the control's
<code>ConstructL()</code> function.</p>
<p>Note:</p>
<ul>
<li>
<p>The use of window owning controls is discouraged, as these
tax run-time resources. Ideally only the top level control in an appUi would be
window owning. There are some exceptions to this rule e.g. floating controls
like menus, dialogs and scroll bars.</p>
</li>
<li>
<p>In general, the first overload should be used.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const CCoeControl* aParent</code></td>
<td class="Cell"><p class="ValueDesc">The control to be the parent of this control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCreateWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>CreateWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CreateWindowL(RWindowTreeNode&amp; aParent);</code></p><h4 class="subheading">Description</h4>
<p>Creates a control's window — specifying its parent
window.</p>
<p>This function makes the specified control a window-owning
control, and would typically be called in the control's
<code>ConstructL()</code> function.</p>
<p>Note:</p>
<ul>
<li>
<p>The use of window owning controls is discouraged, as these
tax run-time resources. Ideally only the top level control in an appUi would be
window owning. There are some exceptions to this rule e.g. floating controls
like menus, dialogs and scroll bars.</p>
</li>
<li>
<p>In general, the first overload should be used.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindowTreeNode&amp; aParent</code></td>
<td class="Cell"><p class="ValueDesc">The window of the control to be the parent of this
control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCreateWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>CreateWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CreateWindowL(RWindowGroup* aParent);</code></p><h4 class="subheading">Description</h4>
<p>Creates a control's window — specifying its parent window
group.</p>
<p>This function makes the specified control a window-owning
control, and would typically be called in the control's
<code>ConstructL()</code> function.</p>
<p>Note:</p>
<ul>
<li>
<p>The use of window owning controls is discouraged, as these
tax run-time resources. Ideally only the top level control in an appUi would be
window owning. There are some exceptions to this rule e.g. floating controls
like menus, dialogs and scroll bars.</p>
</li>
<li>
<p>In general, the first overload should be used.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindowGroup* aParent</code></td>
<td class="Cell"><p class="ValueDesc">The window group of the control to be the parent of this
control</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.6"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aOwnsWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>OwnsWindow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool OwnsWindow() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control is window-owning.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control is window-owning.
<code>EFalse</code> if the control is non-window-owning.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.7"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>Window()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: RWindow&amp; Window() const;</code></p><h4 class="subheading">Description</h4>
<p>Get control's associated window. </p>
<p>The control must be window owning, and the window must be of
type <code>RWindow</code>. If you don't know whether the window is of type
<code>RWindow</code> or <code>RBackedUpWindow</code>, you should use
<code>DrawableWindow()</code>.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindow&amp;</code></td>
<td class="Cell"><p class="ValueDesc">The control's associated window, cast to an
<code>RWindow</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.8"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aDrawableWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawableWindow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>RDrawableWindow* DrawableWindow() const;</code></p><h4 class="subheading">Description</h4>
<p>Get control's associated drawable window. The control must be a
window-owning control. </p>
<p>This function should be called if it is not known whether the
window is of type <code>RWindow</code> or <code>RBackedUpWindow</code>.
<code>RDrawableWindow</code> is an abstract base class from which
<code>RWindow</code> and <code>RBackedUpWindow</code> are derived.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RDrawableWindow*</code></td>
<td class="Cell"><p class="ValueDesc">The control's associated window.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aWindow%28%29" title="Get control's associated window"><code class="ApiItem">Window()</code></a></li>
</ul>
<a name="2.8.9"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCreateBackedUpWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>CreateBackedUpWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CreateBackedUpWindowL(RWindowTreeNode&amp; aParent);</code></p><h4 class="subheading">Description</h4>
<p>Create a control's window as a backed-up window.</p>
<p>The new window is the child of <code>aParent</code> and the
display mode of the control becomes the same as that of
<code>aParent</code>.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindowTreeNode&amp; aParent</code></td>
<td class="Cell"><p class="ValueDesc">The window to be the parent of this control's window. Does not
have to be a backed-up window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.10"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCreateBackedUpWindowL%28%29"></a>
<hr size="1" noshade>
<h3><code>CreateBackedUpWindowL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CreateBackedUpWindowL(RWindowTreeNode&amp; aParent,TDisplayMode aDisplayMode);</code></p><h4 class="subheading">Description</h4>
<p>Create a control's window as a backed-up window, specifying the
display mode.</p>
<p>The new window is the child of <code>aParent</code> and the
display mode of the control is set to <code>aDisplayMode</code>.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RWindowTreeNode&amp; aParent</code></td>
<td class="Cell"><p class="ValueDesc">The window of the control to be the parent of this control.
Does not have to be a backed-up window.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">TDisplayMode aDisplayMode</code></td>
<td class="Cell"><p class="ValueDesc">The display mode of the backed-up window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.11"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsBackedUp%28%29"></a>
<hr size="1" noshade>
<h3><code>IsBackedUp()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool IsBackedUp() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the window owned by the control is a backed-up
window.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the window owned by this control is a
backed-up window. <code>EFalse</code> if the window is not a backed-up
window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.12"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aBackedUpWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>BackedUpWindow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: RBackedUpWindow&amp; BackedUpWindow() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the backed-up window owned by control. </p>
<p>The window must be of type <code>RBackedUpWindow</code>. If you
don't know whether the window is of type <code>RWindow</code> or
<code>RBackedUpWindow</code>, you should use
<code>DrawableWindow()</code>.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">RBackedUpWindow&amp;</code></td>
<td class="Cell"><p class="ValueDesc">The control's associated window, cast to an
<code>RBackedUpWindow</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.13"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetBlank%28%29"></a>
<hr size="1" noshade>
<h3><code>SetBlank()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetBlank();</code></p><h4 class="subheading">Description</h4>
<p>Sets a flag to indicate the control is blank. </p>
<p>Once set, this flag cannot be unset for the lifetime of the
control.</p>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aIsBlank%28%29" title="Tests if the control is a blank"><code class="ApiItem">IsBlank()</code></a></li>
</ul>
<a name="2.8.14"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsBlank%28%29"></a>
<hr size="1" noshade>
<h3><code>IsBlank()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: TBool IsBlank() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control is a blank. </p>
<p>This simply gets the value of the flag set by
<code>SetBlank()</code>.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if <code>SetBlank()</code> has been called
on the control. <code>EFalse</code> if <code>SetBank()</code> has not been
called on the control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.8.15"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCloseWindow%28%29"></a>
<hr size="1" noshade>
<h3><code>CloseWindow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void CloseWindow();</code></p><h4 class="subheading">Description</h4>
<p>Closes window owned by this control. </p>
<p>It is called from <code>CCoeControl</code>'s destructor for
window-owning controls.</p>
<a name="2.9"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Setting and querying size, position and extent</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>A control's origin is its top-left corner. The position of a
control is specified relative to the origin of its associated window.</p>
<a name="2.9.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetExtentL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetExtentL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetExtentL(const TPoint&amp; aPosition,const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's extent — specifying size and
position.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChangedL()</code>.</p>
</li>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SetExtent()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TPoint&amp; aPosition</code></td>
<td class="Cell"><p class="ValueDesc">The position of the control, relative to its associated
window.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The size of the control, in pixels.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetExtent%28%29"></a>
<hr size="1" noshade>
<h3><code>SetExtent()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetExtent(const TPoint&amp; aPosition,const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's extent — specifying size and
position.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChanged()</code>.</p>
</li>
<li>
<p>This function replaces the ER5 function:
<code>SetExtentL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TPoint&amp; aPosition</code></td>
<td class="Cell"><p class="ValueDesc">The position of the control, relative to its associated
window.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The size of the control, in pixels.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetRectL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetRectL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetRectL(const TRect&amp; aRect);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's extent — specifying a
<code>TRect</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChangedL()</code>.</p>
</li>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SetRect()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TRect&amp; aRect</code></td>
<td class="Cell"><p class="ValueDesc">The rectangle that defines the control's extent. The
rectangle's origin is relative to the origin of its associated window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.6"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetRect%28%29"></a>
<hr size="1" noshade>
<h3><code>SetRect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetRect(const TRect&amp; aRect);</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's extent — specifying a
<code>TRect</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChanged()</code>.</p>
</li>
<li>
<p>This function replaces the ER5 function:
<code>SetRectL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TRect&amp; aRect</code></td>
<td class="Cell"><p class="ValueDesc">The rectangle that defines the control's extent. The
rectangle's origin is relative to the origin of its associated window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.7"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aRect%28%29"></a>
<hr size="1" noshade>
<h3><code>Rect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TRect Rect() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the control's extent.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TRect</code></td>
<td class="Cell"><p class="ValueDesc">The control's extent.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.8"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetSizeL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetSizeL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetSizeL(const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's size.</p>
<p>If the size, but not the position, of a control is set, then
its position will default to <code>TPoint(0,0)</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChangedL()</code>.</p>
</li>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SetSize()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size, in pixels.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.9"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetSize%28%29"></a>
<hr size="1" noshade>
<h3><code>SetSize()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetSize(const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's size.</p>
<p>If the size, but not the position, of a control is set, then
its position will default to <code>TPoint(0,0)</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChanged()</code>.</p>
</li>
<li>
<p>This function replaces the ER5 function:
<code>SetSizeL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size, in pixels.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.10"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetSizeWithoutNotificationL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetSizeWithoutNotificationL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetSizeWithoutNotificationL(const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets a control's size without calling
<code>SizeChangedL()</code>.</p>
<p>If the size, but not the position, of a control is set, then
its position will default to <code>TPoint(0,0)</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SetSizeWithoutNotification()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size, in pixels.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetSizeL%28%29" title="Sets the control's size"><code class="ApiItem">SetSizeL()</code></a></li>
</ul>
<a name="2.9.11"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetSizeWithoutNotification%28%29"></a>
<hr size="1" noshade>
<h3><code>SetSizeWithoutNotification()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetSizeWithoutNotification(const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets a control's size without calling
<code>SizeChanged()</code>.</p>
<p>If the size, but not the position, of a control is set, then
its position will default to <code>TPoint(0,0)</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>This function replaces the ER5 function:
<code>SetSizeWithoutNotificationL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size, in pixels.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetSize%28%29" title="Sets the control's size"><code class="ApiItem">SetSize()</code></a></li>
</ul>
<a name="2.9.12"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSize%28%29"></a>
<hr size="1" noshade>
<h3><code>Size()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TSize Size() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the control's size.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size, in pixels.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.13"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetPosition%28%29"></a>
<hr size="1" noshade>
<h3><code>SetPosition()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetPosition(const TPoint&amp; aPosition);</code></p><h4 class="subheading">Description</h4>
<p>Sets the control's position.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TPoint&amp; aPosition</code></td>
<td class="Cell"><p class="ValueDesc">The position of the control, relative to its associated
window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.14"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aPosition%28%29"></a>
<hr size="1" noshade>
<h3><code>Position()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TPoint Position() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the control's position.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TPoint</code></td>
<td class="Cell"><p class="ValueDesc">The position of the control, relative to its associated
window.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.15"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aPositionRelativeToScreen%28%29"></a>
<hr size="1" noshade>
<h3><code>PositionRelativeToScreen()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TPoint PositionRelativeToScreen() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the control's position relative to screen origin. </p>
<p>The screen origin is its top-left corner.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TPoint</code></td>
<td class="Cell"><p class="ValueDesc">The position of the control, measured in pixels, relative to
the screen origin.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.16"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetExtentToWholeScreenL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetExtentToWholeScreenL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetExtentToWholeScreenL();</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's extent to the whole screen.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChangedL()</code>.</p>
</li>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SetExtentToWholeScreen()</code>.</p>
</li>
</ul>
<a name="2.9.17"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetExtentToWholeScreen%28%29"></a>
<hr size="1" noshade>
<h3><code>SetExtentToWholeScreen()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetExtentToWholeScreen();</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's extent to the whole screen.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChanged()</code>.</p>
</li>
<li>
<p>This function replaces the ER5 function:
<code>SetExtentToWholeScreenL()</code>.</p>
</li>
</ul>
<a name="2.9.18"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetCornerAndSizeL%28%29"></a>
<hr size="1" noshade>
<h3><code>SetCornerAndSizeL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetCornerAndSizeL(TCoeAlignment aCorner,const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's position by setting its screen alignment and
size. </p>
<p>The control's position is calculated, relative to the screen,
according to the requested alignment.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChangedL()</code>.</p>
</li>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SetCornerAndSize()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TCoeAlignment aCorner</code></td>
<td class="Cell"><p class="ValueDesc">The alignment of the control.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.19"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetCornerAndSize%28%29"></a>
<hr size="1" noshade>
<h3><code>SetCornerAndSize()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetCornerAndSize(TCoeAlignment aCorner,const TSize&amp; aSize);</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Sets the control's position by setting its screen alignment and
size. </p>
<p>The control's position is calculated, relative to the screen,
according to the requested alignment.</p>
<p>Note:</p>
<ul>
<li>
<p>Calling this function results in a call to
<code>SizeChanged()</code>.</p>
</li>
<li>
<p>This function replaces the ER5 function:
<code>SetCornerAndSizeL()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TCoeAlignment aCorner</code></td>
<td class="Cell"><p class="ValueDesc">The alignment of the control.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">const TSize&amp; aSize</code></td>
<td class="Cell"><p class="ValueDesc">The control's size.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.20"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aMinimumSize%28%29"></a>
<hr size="1" noshade>
<h3><code>MinimumSize()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TSize MinimumSize();</code></p><h4 class="subheading">Description</h4>
<p>Sets the control's minimum required size.</p>
<p>This function should be overridden by the concrete control
class if the control is to be displayed inside a dialog. Standard GUI dialogs
set the size and position of their components automatically, and use this
function to inquire the minimum size that a control requires.</p>
<p>Other container controls that automatically calculate the
layout of their components may also use this function.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TSize</code></td>
<td class="Cell"><p class="ValueDesc">The minimum size required by the control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9.21"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSizeChangedL%28%29"></a>
<hr size="1" noshade>
<h3><code>SizeChangedL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual void SizeChangedL();</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Responds to size changes to sets the size and position of the
contents of this control. </p>
<p>For a simple control this might include text or graphics. For a
compound control this sets the size and position of the component. It has an
empty default implementation and should be implemented by the
<code>CCoeControl</code>-derived class.</p>
<p>The function is called whenever <code>SetExtentL()</code>,
<code>SetSizeL()</code>, <code>SetRectL()</code>,
<code>SetCornerAndSizeL()</code>, or <code>SetExtentToWholeScreenL()</code> are
called on the control. Note that the window server does not generate
size-changed events: <code>SizeChangedL()</code> gets called only as a result
of calling the functions listed above. Therefore, if a resize of one control
affects the size of other controls, it is up to the application to ensure that
it handles the re-sizing of all affected controls.</p>
<p>Note:</p>
<ul>
<li>
<p>This function is replaced by a non-leaving variant after
ER5: <code>SizeChanged()</code>.</p>
</li>
</ul>
<a name="2.9.22"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSizeChanged%28%29"></a>
<hr size="1" noshade>
<h3><code>SizeChanged()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual void SizeChanged();</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Responds to size changes to sets the size and position of the
contents of this control. </p>
<p>For a simple control this might include text or graphics. For a
compound control this sets the size and position of the component. It has an
empty default implementation and should be implemented by the
<code>CCoeControl</code>-derived class.</p>
<p>The function is called whenever <code>SetExtent()</code>,
<code>SetSize()</code>, <code>SetRect()</code>,
<code>SetCornerAndSize()</code>, or <code>SetExtentToWholeScreen()</code> are
called on the control. Note that the window server does not generate
size-changed events: <code>SizeChanged()</code> gets called only as a result of
calling the functions listed above. Therefore, if a resize of one control
affects the size of other controls, it is up to the application to ensure that
it handles the re-sizing of all affected controls.</p>
<p>Note:</p>
<ul>
<li>
<p>This function replaces the ER5 function:
<code>SizeChangedL()</code>.</p>
</li>
</ul>
<a name="2.9.23"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aPositionChanged%28%29"></a>
<hr size="1" noshade>
<h3><code>PositionChanged()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual void PositionChanged();</code></p><h4 class="subheading">Description</h4>
<p>Responds to changes in the position of a control. </p>
<p>It has an empty default implementation which may be overridden
by the <code>CCoeControl</code>-derived class.</p>
<p>This function is called by whenever the application calls
<code>SetPosition()</code> on the control. </p>
<a name="2.10"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Activating a control</h2>
</div><div class="Bodytext">
<a name="2.10.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aActivateL%28%29"></a>
<hr size="1" noshade>
<h3><code>ActivateL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void ActivateL();</code></p><h4 class="subheading">Description</h4>
<p>Sets control as ready to be drawn. </p>
<p>The application should call this function on all controls that
are not components in a compound control.</p>
<p>The purpose of this function is that controls are not always
ready to draw as soon as they have been constructed. For example, it may not be
possible to set the control's extent during construction, but its extent should
always be set before it is drawn. Similarly, if a control is to be made
invisible, this should be done before it is activated.</p>
<p>The default implementation sets a flag in the control to
indicate it is ready to be drawn. If the control is a compound control, the
default implementation also calls <code>ActivateL()</code> for all the
control's components. To get the control's components it uses
<code>CountComponentControls()</code> and <code>ComponentControl()</code>,
which should be implemented by the compound control.</p>
<p><code>ActivateL()</code> is typically called from the control's
<code>ConstructL()</code> function .</p>
<p>Notes:</p>
<ul>
<li>
<p>This function can be overridden. This is useful for doing
late initialisation of the control, using information that was not available at
the time the control was created. For example, <code>CEikEdwin</code> overrides
<code>ActivateL()</code> and uses it to inquire if the edit window is focused:
if it is, it highlights the text and makes the cursor visible. At the time when
the edit window is created, it doesn't know whether or not it has keyboard
focus.</p>
</li>
</ul>
<a name="2.10.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsActivated%28%29"></a>
<hr size="1" noshade>
<h3><code>IsActivated()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: TBool IsActivated() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control has been activated. </p>
<p>A control is not ready to draw until it is activated.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control is activated,
<code>EFalse</code> if it is not activated.</p></td>
</tr>
</table></td></tr></table>
<a name="2.10.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsReadyToDraw%28%29"></a>
<hr size="1" noshade>
<h3><code>IsReadyToDraw()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: TBool IsReadyToDraw() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control is ready for drawing. </p>
<p>This returns true if the control has been activated and is
visible.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control is ready for drawing,
<code>EFalse</code> if it is not ready for drawing.</p></td>
</tr>
</table></td></tr></table>
<a name="2.11"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Drawing</h2>
</div><div class="Bodytext">
<a name="2.11.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aDraw%28%29"></a>
<hr size="1" noshade>
<h3><code>Draw()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>private: virtual void Draw(const TRect&amp; aRect) const;</code></p><h4 class="subheading">Description</h4>
<p>Draw a control — called by window server. </p>
<p>All controls, except blank controls, should implement this
function. The default implementation draws a blank control.</p>
<p>This function is used for window server-initiated redrawing of
controls, and for some application-initiated drawing. It should be implemented
by each control, but is only called from within <code>CCoeControl</code>'s
member functions, and not from the derived class. For this reason it is a
private member function of <code>CCoeControl</code>.</p>
<p>The rectangle <code>aRect</code> indicates the region of the
control that needs to be redrawn. The implementation of <code>Draw()</code>must
always draw to every pixel within this rectangle.</p>
<p>Notes:</p>
<ul>
<li>
<p>For non-window-owning controls, care must be taken not to
draw outside the control, as drawing will not be clipped to the control.
Drawing is clipped to window-owning-controls, but not to non-window-owning
controls.</p>
</li>
<li>
<p>Drawing outside <code>aRect</code> may cause
flicker.</p>
</li>
<li>
<p>Drawing should be done using a graphics context
(<code>CWindowGc</code>), which can be obtained using
<code>SystemGc()</code>.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TRect&amp; aRect</code></td>
<td class="Cell"><p class="ValueDesc">The region of the control to be redrawn. Co-ordinates are
relative to the control's origin (top left corner).</p></td>
</tr>
</table></td></tr></table>
<a name="2.11.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aDrawNow%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawNow()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void DrawNow() const;</code></p><h4 class="subheading">Description</h4>
<p>Draws a control — called by an application or other code.
</p>
<p>The application should call this function when the control is
first created and is ready for drawing, or if a change in application data or
the control's internal state means that entire control's appearance is no
longer up-to-date.</p>
<p>Partial redrawing of a control is sometimes more appropriate
than drawing the entire control, and in this case <code>DrawNow()</code> should
not be used.</p>
<p><code>DrawNow()</code> is implemented by
<code>CCoeControl</code> and MAY NOT be overridden. It calls
<code>Draw()</code> on the control itself, and also on all its component
controls, if it is a compound control. (To do this it uses
<code>CountComponentControls()</code> and <code>ComponentControl()</code>,
which should be implemented by the derived control class.) If the control is a
window-owning control, it also calls <code>Draw()</code> for its child windows
(if any).</p>
<a name="2.11.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aDrawDeferred%28%29"></a>
<hr size="1" noshade>
<h3><code>DrawDeferred()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void DrawDeferred() const;</code></p><h4 class="subheading">Description</h4>
<p>Draws the control with low priority — called by
application</p>
<p>This function causes the control area to be marked as invalid,
which will eventually cause a redraw initiated by the window server. The
control framework handles redraw events at a lower priority than user input
events, which means that any pending user input events will be processed before
the redraw event. <code>DrawDeferred()</code> therefore allows a control to do
drawing at a lower priority than drawing performed by
<code>DrawNow()</code>.</p>
<p>An advantage of using <code>DrawDeferred()</code> is that if
you make multiple calls to <code>DrawDeferred()</code> on the same area of a
control, the window server will not generate a redraw event to do drawing that
has already been superseded. If you make multiple calls to
<code>DrawNow()</code>, however, all of them get processed, even if they have
already been superseded by the time they are processed.</p>
<a name="2.11.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetCanDrawOutsideRect%28%29"></a>
<hr size="1" noshade>
<h3><code>SetCanDrawOutsideRect()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetCanDrawOutsideRect();</code></p><h4 class="subheading">Description</h4>
<p>Allows the control to draw outside its own extent.</p>
<p>When a compound control is drawn, all its component controls
are also drawn. However, unless this flag is set, they are not drawn if the
rectangle they inhabit on the screen doesn't intersect with the rectangle to be
drawn.</p>
<p>Setting this flag has the effect of allowing a component
control to draw outside its own extent. It should be used with caution! By
default, this flag is not set.</p>
<a name="2.11.6"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aGetColor%28%29"></a>
<hr size="1" noshade>
<h3><code>GetColor()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool GetColor(TInt aLogicalColor,TRgb&amp; aColor) const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the over-ridden physical colour. </p>
<p>This is the colour which has been mapped to the logical colour
specified by a call to <code>OverrideColorL()</code>. If the logical colour
specified has not been overridden, the <code>aColor</code> value is not
changed.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt aLogicalColor</code></td>
<td class="Cell"><p class="ValueDesc">The logical colour for which the corresponding physical colour
will be retrieved. The set of logical colours for a standard GUI application
are defined in the <code>TLogicalColor</code>.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">TRgb&amp; aColor</code></td>
<td class="Cell"><p class="ValueDesc">On return, contains the physical colour which has been mapped
to <code>aLogicalColour</code> by a call to
<code>OverrideColorL()</code>.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if <code>aLogicalColour</code> has been
overridden, <code>EFalse</code> otherwise.</p></td>
</tr>
</table></td></tr></table>
<a name="2.11.7"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aOverrideColorL%28%29"></a>
<hr size="1" noshade>
<h3><code>OverrideColorL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void OverrideColorL(TInt aLogicalColor,TRgb aColor);</code></p><h4 class="subheading">Description</h4>
<p>Overrides the control's colour setting, as specified in the
application's colour scheme. </p>
<p>This function does not change the application's colour scheme
— it changes the colour mapping used in this control only.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt aLogicalColor</code></td>
<td class="Cell"><p class="ValueDesc">The logical colour. Indicates which part of a control the
physical colour maps to. The set of logical colours for a standard application
are defined in <code>TLogicalColor</code>.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">TRgb aColor</code></td>
<td class="Cell"><p class="ValueDesc">The new physical colour to which the logical colour should be
mapped.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">This function can only leave with <code>KErrNoMemory</code>.
</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aGetColor%28%29" title="Gets the over-ridden physical colour"><code class="ApiItem">GetColor()</code></a></li>
</ul>
<a name="2.11.8"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aGetColorUseListL%28%29"></a>
<hr size="1" noshade>
<h3><code>GetColorUseListL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void GetColorUseListL(CArrayFix&lt;TCoeColorUse&gt;&amp; aColorUseList) const; </code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Gets the list of logical colours used to draw the control.
</p>
<p>The list includes an explanation of how each colour is used. By
default, this function has an empty implementation. </p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">CArrayFix&lt;TCoeColorUse&gt;&amp; aColorUseList</code></td>
<td class="Cell"><p class="ValueDesc">The colour list.</p></td>
</tr>
</table></td></tr></table>
<a name="2.12"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Graphics contexts</h2>
</div><div class="Bodytext">
<a name="2.12.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSystemGc%28%29"></a>
<hr size="1" noshade>
<h3><code>SystemGc()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: CWindowGc&amp; SystemGc() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the standard graphics context for use when drawing
controls. </p>
<p>All graphics functions are carried out through a graphics
context.</p>
<p>Note:</p>
<ul>
<li>
<p>A graphics context must be activated before it can be drawn
to, and deactivated when it is no longer needed. When drawing is done using
<code>Draw()</code>, <code>DrawNow()</code> or <code>DrawDeferred()</code>, the
application does not have to do this, as it is done within control framework.
However, for application-initiated drawing which is not done using
<code>DrawNow()</code> or <code>DrawDeferred()</code>, the application should
activate and deactivate the graphics context using <code>ActivateGc()</code>
and <code>DeactivateGc()</code> (or <code>CWindowGc::Activate()</code> and
<code>CWindowGc::Deactivate()</code>).</p>
</li>
</ul>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">CWindowGc&amp;</code></td>
<td class="Cell"><p class="ValueDesc">The system graphics context.</p></td>
</tr>
</table></td></tr></table>
<a name="2.12.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aActivateGc%28%29"></a>
<hr size="1" noshade>
<h3><code>ActivateGc()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void ActivateGc() const;</code></p><h4 class="subheading">Description</h4>
<p>Activates the standard graphics context. </p>
<p>This is the graphics context owned by the control environment
(<code>CCoeEnv</code>).</p>
<p>Applications should not normally need to call this function, as
it is called within the control framework whenever it is about to call
<code>Draw()</code>.</p>
<a name="2.12.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aResetGc%28%29"></a>
<hr size="1" noshade>
<h3><code>ResetGc()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void ResetGc() const;</code></p><h4 class="subheading">Description</h4>
<p>Resets the standard graphics context. </p>
<p>The function resets the graphics context owned by the control
environment to its default settings.</p>
<a name="2.12.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aDeactivateGc%28%29"></a>
<hr size="1" noshade>
<h3><code>DeactivateGc()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void DeactivateGc() const;</code></p><h4 class="subheading">Description</h4>
<p>Deactivates the standard graphics context owned by the UI
control framework.</p>
<p>Applications should not normally need to call this function, as
it is called within control framework whenever it has called
<code>Draw()</code> and drawing is completed.</p>
<a name="2.13"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Control contexts</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>Control contexts allow a group of controls to share a common set
of graphics context settings, and hence a common appearance.</p>
<a name="2.13.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetControlContext%28%29"></a>
<hr size="1" noshade>
<h3><code>SetControlContext()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetControlContext(MCoeControlContext* aContext);</code></p><h4 class="subheading">Description</h4>
<p>Set the control context for this control.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">MCoeControlContext* aContext</code></td>
<td class="Cell"><p class="ValueDesc">The context for this control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.13.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCopyControlContextFrom%28%29"></a>
<hr size="1" noshade>
<h3><code>CopyControlContextFrom()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void CopyControlContextFrom(const CCoeControl* aControl);</code></p><h4 class="subheading">Description</h4>
<p>Sets the control's context from another control.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const CCoeControl* aControl</code></td>
<td class="Cell"><p class="ValueDesc">The control whose context to copy.</p></td>
</tr>
</table></td></tr></table>
<a name="2.14"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Making controls invisible</h2>
</div><div class="Bodytext">
<a name="2.14.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aMakeVisible%28%29"></a>
<hr size="1" noshade>
<h3><code>MakeVisible()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void MakeVisible(TBool aVisible);</code></p><h4 class="subheading">Description</h4>
<p>Sets this control as visible or invisible. </p>
<p>This causes the control to disappear or reappear. When a
control is created, it is made visible by default.</p>
<p><code>MakeVisible()</code> can be called before of after the
control is activated.</p>
<p>Note:</p>
<ul>
<li>
<p>This function may be overridden.</p>
</li>
<li>
<p>The visibility of the control can be queried using
<code>IsVisible()</code>.</p>
</li>
<li>
<p>If <code>MakeVisible()</code> is used to make a component
visible, and the control captures the pointer (see
<code>CapturesPointer()</code>), <code>MakeVisible()</code> throws away any
pending pointer events for that control.</p>
</li>
<li>
<p>Typical uses are for scrollbars, or for dialogs where some
user responses are not required in certain circumstances.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aVisible</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> to make the control visible,
<code>EFalse</code> to make it invisible.</p></td>
</tr>
</table></td></tr></table>
<a name="2.14.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsVisible%28%29"></a>
<hr size="1" noshade>
<h3><code>IsVisible()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool IsVisible() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control is visible.</p>
<p>Unless <code>MakeVisible()</code> has been called with argument
<code>EFalse</code>, the control is visible.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control is visible,
<code>EFalse</code> if it is invisible.</p></td>
</tr>
</table></td></tr></table>
<a name="2.14.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetComponentsToInheritVisibility%28%29"></a>
<hr size="1" noshade>
<h3><code>SetComponentsToInheritVisibility()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetComponentsToInheritVisibility(TBool aInherit=ETrue);</code></p><h4 class="subheading">Description</h4>
<p>Sets components to inherit visibility setting from their
container control. </p>
<p>If set, when <code>MakeVisible()</code> is called on the
compound control, the value for visibility is propagated to all its
components.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aInherit=ETrue</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> to set that the control's components inherit
its visibility setting, <code>EFalse</code> to set that they do not inherit its
visibility setting.</p></td>
</tr>
</table></td></tr></table>
<a name="2.15"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Making controls dimmed</h2>
</div><div class="Bodytext">
<a name="2.15.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetDimmed%28%29"></a>
<hr size="1" noshade>
<h3><code>SetDimmed()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void SetDimmed(TBool aDimmed);</code></p><h4 class="subheading">Description</h4>
<p>Sets control dimmed.</p>
<p>This function sets a flag within the control which indicates
whether or not the control is dimmed (greyed out). This is typically used to
show that the action performed by the control is temporarily
unavailable.</p>
<p><code>SetDimmed()</code> does not initiate a redraw of the
control. The application should call <code>DrawNow()</code> or
<code>DrawDeferred()</code> if a redraw is required after calling
<code>SetDimmed()</code>. The control's <code>Draw()</code> function should
draw the control appropriately according to whether it is dimmed or not. (This
can be inquired using <code>IsDimmed()</code>.)</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aDimmed</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> to dim the control, <code>EFalse</code> to
set the control as not dimmed.</p></td>
</tr>
</table></td></tr></table>
<a name="2.15.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsDimmed%28%29"></a>
<hr size="1" noshade>
<h3><code>IsDimmed()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool IsDimmed() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if control is dimmed.</p>
<p>This function returns the value of a flag within the control
which is set and unset using <code>SetDimmed()</code>.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control is dimmed,
<code>EFalse</code> if it is not dimmed.</p></td>
</tr>
</table></td></tr></table>
<a name="2.16"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Keyboard focus</h2>
</div><div class="Bodytext">
<a name="2.16.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetFocus%28%29"></a>
<hr size="1" noshade>
<h3><code>SetFocus()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetFocus(TBool aFocus,TDrawNow aDrawNow=ENoDrawNow);</code></p><h4 class="subheading">Description</h4>
<p>Sets that the control has keyboard focus.</p>
<p>The function sets the value of a focus flag within the control
to the value given by <code>aFocus</code>. This flag indicates whether or not
the control has keyboard focus, and its value can be inquired using
<code>IsFocused()</code>. It then calls <code>FocusChanged()</code>, passing it
the value given by <code>aDrawNow</code>, unless the control is invisible or
not activated, in which case it passes <code>ENoDrawNow</code>.</p>
<p>Note that setting focus does not initiate a redraw. The
control's implementation of <code>FocusChanged()</code> should do this if
required. The control's <code>Draw()</code> function, or that of its container,
should normally change the appearance of the control to indicate whether or not
it currently has focus.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aFocus</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> sets the control as having keyboard focus,
<code>EFalse</code> sets it as not having keyboard focus.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">TDrawNow aDrawNow=ENoDrawNow</code></td>
<td class="Cell"><p class="ValueDesc">Flag to pass to <code>FocusChanged()</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.16.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aPrepareForFocusLossL%28%29"></a>
<hr size="1" noshade>
<h3><code>PrepareForFocusLossL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void PrepareForFocusLossL();</code></p><h4 class="subheading">Description</h4>
<p>Prepare for focus loss. </p>
<p>A control which is displayed within a dialog should implement
this function if it wishes to validate data entered into the control.</p>
<p>This function is called by the dialog framework immediately
before it removes keyboard focus from a control within a dialog. It is intended
to be used for validating the state of the control: for example, if the control
allows the user to enter a date, <code>PrepareForFocusLossL()</code> would
normally check to make sure the user did not enter an invalid date such as
February 31st. If an invalid state is detected,
<code>PrepareForFocusLossL()</code> should leave and issue a message to the
user if appropriate. If it does leave, the framework does not perform the
action that would have resulted in the control losing focus, and focus remains
with the control to allow valid data to be entered.</p>
<p>In standard GUI dialogs, two actions result in a control losing
focus: one is when the user presses the OK button or the Enter key, to close
the dialog and enter the information, and the second is when the user presses
the up or down arrow keys to change the keyboard focus within the dialog. All
these actions result in <code>PrepareForFocusLossL()</code> being called on the
control that currently has keyboard focus.</p>
<p>The default implementation of this function is empty, and it is
not called from within the UI control framework. The function exists only to
provide an interface to the control, for the GUI and any other UI
library.</p>
<a name="2.16.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aPrepareForFocusGainL%28%29"></a>
<hr size="1" noshade>
<h3><code>PrepareForFocusGainL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void PrepareForFocusGainL();</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Prepares the control for gaining focus.</p>
<p>Implementations may by taking any action required, such as
updating control information. By default, the implementation is empty. </p>
<a name="2.16.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aFocusChanged%28%29"></a>
<hr size="1" noshade>
<h3><code>FocusChanged()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual void FocusChanged(TDrawNow aDrawNow);</code></p><h4 class="subheading">Description</h4>
<p>Responds to focus changed.</p>
<p>This function is called whenever a control gains or loses focus
— as a result of a call to <code>SetFocus()</code>. A typical use of
<code>FocusChanged()</code> is to change the appearance of the control to
indicate whether or not it has focus, for example by drawing a focus rectangle
around it.</p>
<p>The default implementation is empty, and should be overridden
by the <code>CCoeControl</code>-derived class.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TDrawNow aDrawNow</code></td>
<td class="Cell"><p class="ValueDesc">Contains the value that was passed to it by
<code>SetFocus()</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.16.6"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsFocused%28%29"></a>
<hr size="1" noshade>
<h3><code>IsFocused()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool IsFocused() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control has focus. </p>
<p>Focus is set and unset using <code>SetFocus()</code>.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control has focus,
<code>EFalse</code> if it doesn't.</p></td>
</tr>
</table></td></tr></table>
<a name="2.16.7"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetNonFocusing%28%29"></a>
<hr size="1" noshade>
<h3><code>SetNonFocusing()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetNonFocusing();</code></p><h4 class="subheading">Description</h4>
<p>Deprecated. Use <code>SetFocusing()</code>.</p>
<p>Sets the control as unable to receive keyboard focus. The
function would typically be called during construction of the control.</p>
<a name="2.16.8"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetFocusing%28%29"></a>
<hr size="1" noshade>
<h3><code>SetFocusing()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetFocusing(TBool aFocusing);</code></p><h4 class="subheading">Description</h4>
<p>Sets the control as able to receive keyboard focus. </p>
<p>The function would typically be called after construction of
the control.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aFocusing</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control can have focus,
<code>EFalse</code> if it cant.</p></td>
</tr>
</table></td></tr></table>
<a name="2.16.9"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIsNonFocusing%28%29"></a>
<hr size="1" noshade>
<h3><code>IsNonFocusing()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TBool IsNonFocusing() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if the control can receive focus.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control cannot receive focus,
<code>EFalse</code> if it can.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aSetNonFocusing%28%29" title="Deprecated"><code class="ApiItem">SetNonFocusing()</code></a></li>
</ul>
<a name="2.17"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Handling key and pointer events</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>The functions grouped below handle key and pointer events and
sending events to another control.</p>
<a name="2.17.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aOfferKeyEventL%28%29"></a>
<hr size="1" noshade>
<h3><code>OfferKeyEventL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TKeyResponse OfferKeyEventL(const TKeyEvent&amp; aKeyEvent,TEventCode aType);</code></p><h4 class="subheading">Description</h4>
<p>Handles key events.</p>
<p>If a control wishes to process key events, it should implement
this function. The implementation must ensure that the function returns
<code>EKeyWasNotConsumed</code> if it does not do anything in response to a key
event — otherwise, other controls or dialogs may be prevented from receiving
the key event. If it is able to process the event it should return
<code>EKeyWasConsumed</code>.</p>
<p>When a key event occurs, the control framework calls this
function for each control on the control stack, until one of them can process
the key event (and returns <code>EKeyWasConsumed</code>).</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TKeyEvent&amp; aKeyEvent</code></td>
<td class="Cell"><p class="ValueDesc">The key event.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value">TEventCode aType</code></td>
<td class="Cell"><p class="ValueDesc">The type of key event: <code>EEventKey</code>,
<code>EEventKeyUp</code> or <code>EEventKeyDown</code>.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TKeyResponse</code></td>
<td class="Cell"><p class="ValueDesc">Indicates whether or not the key event was used by this
control.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Notes:</h4>
<ul>
<li><note>Each keyboard key press results in three
separate events: <code>EEventKeyDown</code>, <code>EEventKey</code>, and
<code>EEventKeyUp</code>, in that order. </note></li>
<li><note>To receive key events,
which can be processed by this function, the application should call
<code>CCoeAppUi::AddToStackL()</code> to add the control to the stack. This
only applies, however, to controls which are not components of a compound
control. Compound controls should pass key events to their components as
necessary: the components themselves do not go on the
stack.</note></li>
<li><note>Classes that override
<code>CCoeControl::OfferKeyEventL()</code> should also override the
<code>InputCapabilities()</code> virtual function, returning a
<code>TCoeInputCapabilities</code> object whose attributes correspond to the
behaviour of the <code>OfferKeyEventL()</code> function. Note that it is not
necessary to call <code>InputCapabilities()</code> on any component controls
from inside a class' <code>InputCapabilities()</code> function&#0160;&#8212;  this is done
automatically by the UI Control Framework.</note></li>
</ul>
<a name="2.17.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aHandlePointerEventL%28%29"></a>
<hr size="1" noshade>
<h3><code>HandlePointerEventL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual void HandlePointerEventL(const TPointerEvent&amp; aPointerEvent);</code></p><h4 class="subheading">Description</h4>
<p>Handles pointer events.</p>
<p>This function gets called whenever a pointer event occurs in
the control, i.e. with the pointer within the control's extent, or when the
control has grabbed the pointer. The control should implement this function to
handle pointer events.</p>
<p>Note:</p>
<ul>
<li>
<p>Events of type <code>EButton1Down</code> are processed
before <code>HandlePointerEventL()</code> is called, in order to transfer
keyboard focus to the control in which the <code>EButton1Down</code> event
occurred.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TPointerEvent&amp; aPointerEvent</code></td>
<td class="Cell"><p class="ValueDesc">The pointer event.</p></td>
</tr>
</table></td></tr></table>
<a name="2.17.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetAllowStrayPointers%28%29"></a>
<hr size="1" noshade>
<h3><code>SetAllowStrayPointers()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void SetAllowStrayPointers();</code></p><h4 class="subheading">Description</h4>
<p>Set allow stray pointer events.</p>
<p>This function sets a flag that affects the way the control
framework handles pointer events. By default, the flag is not set, and the
control will ignore any pointer drag events and up events where the matching
pointer down event occurred in a different control. This would happen if a user
pressed the pointer down in a control, but then dragged the pointer into a
different control before releasing it.</p>
<p><code>SetAllowStrayPointers()</code> is typically used for
menus, where stray pointer events are required because is it the pointer up
event that is used to activate a menu option. This is in contrast to other
components such as command buttons, where a pointer down event and up event in
succession are required to activate the button.</p>
<a name="2.17.6"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aEnableDragEvents%28%29"></a>
<hr size="1" noshade>
<h3><code>EnableDragEvents()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void EnableDragEvents();</code></p><h4 class="subheading">Description</h4>
<p>Requests pointer drag events.</p>
<p>This function should be called if a control is required to
receive pointer drag and move events. The default behaviour for all controls is
that pointer drag events and pointer move events are not delivered. </p>
<p>The control framework does not provide a function to disable
drag events at a later time, but this can be done via the window server API, by
calling <code>Window()-&gt;PointerFilter()</code>.</p>
<p>Note:</p>
<ul>
<li>
<p>By default, pointer move events are not delivered, even
after calling <code>EnableDragEvents()</code>, because they are not normally
required in a pen-based system. The window server can be configured to deliver
pointer move events if required, e.g. for a mouse-based system.</p>
</li>
</ul>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="../WindowServerClientSide/RWindowBaseClass.html#%3a%3aRWindowBase%3a%3aPointerFilter%28%29" title="Sets the filter which controls which pointer events are sent to the client session"><code class="ApiItem">RWindowBase::PointerFilter()</code></a></li>
</ul>
<a name="2.17.7"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aHandlePointerBufferReadyL%28%29"></a>
<hr size="1" noshade>
<h3><code>HandlePointerBufferReadyL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: virtual void HandlePointerBufferReadyL();</code></p><h4 class="subheading">Description</h4>
<p>Handle events in pointer buffer.</p>
<p>This function is called whenever the control receives an event
of type <code>EEventPointerBufferReady</code>, unless one of its component
controls has grabbed the pointer, in which case the function is called on that
control. An event of type <code>EEventPointerBufferReady</code> will only be
received if the pointer move buffer has been set up using window server
functions. </p>
<p>The pointer move buffer is typically used when the application
requires a continuous stream of pointer drag events, such as in a drawing
application.</p>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="../WindowServerClientSide/RWindowBaseClass.html#%3a%3aRWindowBase%3a%3aAllocPointerMoveBuffer%28%29" title="Allocates a buffer for storing pointer movements"><code class="ApiItem">RWindowBase::AllocPointerMoveBuffer()</code></a></li>
</ul>
<a name="2.17.8"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aHandleRedrawEvent%28%29"></a>
<hr size="1" noshade>
<h3><code>HandleRedrawEvent()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void HandleRedrawEvent(const TRect&amp; aRect) const;</code></p><h4 class="subheading">Description</h4>
<p>Handles redraw event.</p>
<p>In normal circumstances this function should not be used or
overridden by the derived control class.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">const TRect&amp; aRect</code></td>
<td class="Cell"><p class="ValueDesc">The rectangle to be redrawn.</p></td>
</tr>
</table></td></tr></table>
<a name="2.17.9"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aInputCapabilities%28%29"></a>
<hr size="1" noshade>
<h3><code>InputCapabilities()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TCoeInputCapabilities InputCapabilities() const; </code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Gets the control's input capabilities.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TCoeInputCapabilities</code></td>
<td class="Cell"><p class="ValueDesc">The control's input capabilities.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Notes:</h4>
<ul>
<li><note>Classes that override
<code>CCoeControl::OfferKeyEventL()</code> should also override the
<code>InputCapabilities()</code> virtual function, returning a
<code>TCoeInputCapabilities</code> object whose attributes correspond to the
behaviour of the <code>OfferKeyEventL()</code> function.</note></li>
<li><note>It is not
necessary to call <code>InputCapabilities()</code> on any component controls
from inside a class' <code>InputCapabilities()</code> function&#0160;&#8212;  this is done
automatically by the UI Control Framework.</note></li>
</ul>
<a name="2.17.10"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aRecursivelyMergedInputCapabilities%28%29"></a>
<hr size="1" noshade>
<h3><code>RecursivelyMergedInputCapabilities()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TCoeInputCapabilities RecursivelyMergedInputCapabilities() const;</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Gets the input capabilities of the control and all its
components.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TCoeInputCapabilities</code></td>
<td class="Cell"><p class="ValueDesc">The input capabilities of the control.</p></td>
</tr>
</table></td></tr></table>
<a name="2.18"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Handling changes to resources</h2>
</div><div class="Bodytext">
<a name="2.18.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aHandleResourceChange%28%29"></a>
<hr size="1" noshade>
<h3><code>HandleResourceChange()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void HandleResourceChange(TInt aType);            </code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Handles a change to the control's resources. </p>
<p>The types of resources handled are those which are shared
across the environment, e.g. colours or fonts. </p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt aType</code></td>
<td class="Cell"><p class="ValueDesc">A message UID value. The most common is
<code>KEikMessageColorSchemeChange</code> which controls get when the colour
scheme is changed. Other examples include:
<code>KEikMessageFadeAllWindows</code>, <code>KEikMessageUnfadeWindows</code>,
<code>KEikMessageZoomChange</code>,
<code>KEikMessageVirtualCursorStateChange</code>,
<code>KEikMessageCapsLock</code>,
<code>KEikMessagePrepareForSave</code>.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandleComponentControlsResourceChange%28%29" title="Handles a change to the resources in the components of a compound control"><code class="ApiItem">HandleComponentControlsResourceChange()</code></a></li>
</ul>
<a name="2.18.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aHandleComponentControlsResourceChange%28%29"></a>
<hr size="1" noshade>
<h3><code>HandleComponentControlsResourceChange()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void HandleComponentControlsResourceChange(TInt aType); </code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Handles a change to the resources in the components of a
compound control.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TInt aType</code></td>
<td class="Cell"><p class="ValueDesc">A message UID value. The most common is
<code>KEikMessageColorSchemeChange</code> which controls get when the colour
scheme is changed. Other examples include:
<code>KEikMessageFadeAllWindows</code>, <code>KEikMessageUnfadeWindows</code>,
<code>KEikMessageZoomChange</code>,
<code>KEikMessageVirtualCursorStateChange</code>,
<code>KEikMessageCapsLock</code>,
<code>KEikMessagePrepareForSave</code>.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="CCoeControlClass.html#%3a%3aCCoeControl%3a%3aHandleResourceChange%28%29" title="Handles a change to the control's resources"><code class="ApiItem">HandleResourceChange()</code></a></li>
</ul>
<a name="2.19"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Grabbing the pointer</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p>This is implemented within control framework and does not have to
be implemented by the derived control class.</p>
<p>In the UI control framework, when a pointer event of type
<code>EButton1Down</code> occurs in a control, the control grabs the pointer
until the next event of type <code>EButton1Up</code>. This means, all pointer
events are delivered to this control between (and inclusive of) the
<code>EButton1Down</code> and <code>EButton1Up</code> events, regardless of
which control the event occurs in. (If the control is invisible or dimmed,
however, it does not grab the pointer.)</p>
<a name="2.19.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aClaimPointerGrab%28%29"></a>
<hr size="1" noshade>
<h3><code>ClaimPointerGrab()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void ClaimPointerGrab(TBool aSendUpEvent=ETrue);</code></p><h4 class="subheading">Description</h4>
<p>Claims pointer grab from another control. </p>
<p>This ensures that all subsequent pointer events are delivered
to it and not to the control that originally owned the grab.</p>
<p>The function allows a control to claim the pointer grab only if
the pointer is already grabbed by another control.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aSendUpEvent=ETrue</code></td>
<td class="Cell"><p class="ValueDesc">Passed as the argument to
<code>RWindowBase::ClaimPointerGrab()</code>.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="../WindowServerClientSide/RWindowBaseClass.html#%3a%3aRWindowBase%3a%3aClaimPointerGrab%28%29" title="Claims the pointer grab from another window"><code class="ApiItem">RWindowBase::ClaimPointerGrab()</code></a></li>
</ul>
<a name="2.19.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aGrabbingComponent%28%29"></a>
<hr size="1" noshade>
<h3><code>GrabbingComponent()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: CCoeControl* GrabbingComponent() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the component control which is grabbing the
pointer.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">CCoeControl*</code></td>
<td class="Cell"><p class="ValueDesc">The component control that is currently grabbing the pointer.
If no component of this control is currently grabbing the pointer, or if the
control is not a compound control, returns <code>NULL</code>.</p></td>
</tr>
</table></td></tr></table>
<a name="2.20"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Capturing pointer events</h2>
</div><div class="Bodytext">
<a name="2.20.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetPointerCapture%28%29"></a>
<hr size="1" noshade>
<h3><code>SetPointerCapture()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetPointerCapture(TBool aCapture=ETrue);</code></p><h4 class="subheading">Description</h4>
<p>Set pointer capture. </p>
<p>Once set, pointer capture lasts until
<code>SetPointerCapture()</code> is called on the control with
<code>aCapture=EFalse</code>.</p>
<p>This function is typically used with dialogs, to throw away any
pointer events that don't occur within the dialog, or with menus, to dismiss
the menu if the user clicks outside it.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aCapture=ETrue</code></td>
<td class="Cell"><p class="ValueDesc">If <code>ETrue</code>, passes the following value as the
argument to
<code>RWindowBase::SetPointerCapture()</code>:<code>RWindowBase::TCaptureFlagAllGroups|RWindowBase::TCaptureFlagEnabled</code>,
if the control's global capture flag is set to <code>ETrue</code> (see
<code>SetGloballyCapturing()</code>) or
<code>RWindowBase::TCaptureFlagEnabled</code> if the control's global capture
flag is set to <code>EFalse</code>. If <code>EFalse</code>, passes
<code>EFalse</code> as the argument to
<code>RWindowBase::SetPointerCapture()</code>.</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="../WindowServerClientSide/RWindowBaseClass.html#%3a%3aRWindowBase%3a%3aSetPointerCapture%28%29" title="Sets the pointer capture state"><code class="ApiItem">RWindowBase::SetPointerCapture()</code></a></li>
</ul>
<a name="2.20.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetGloballyCapturing%28%29"></a>
<hr size="1" noshade>
<h3><code>SetGloballyCapturing()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetGloballyCapturing(TBool aGlobal);</code></p><h4 class="subheading">Description</h4>
<p>Sets the global pointer capture flag. </p>
<p>This flag indicates whether or not pointer capture should be
global. </p>
<p>The flag is used by <code>SetPointerCapture()</code> to
determine what value to pass to <code>RWindowBase::SetPointerCapture()</code>.
The default for the global capture flag, when a control is created, is
<code>EFalse</code>.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool aGlobal</code></td>
<td class="Cell"><p class="ValueDesc">Value for global capture flag.</p></td>
</tr>
</table></td></tr></table>
<a name="2.20.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aCapturesPointer%28%29"></a>
<hr size="1" noshade>
<h3><code>CapturesPointer()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: TBool CapturesPointer() const;</code></p><h4 class="subheading">Description</h4>
<p>Tests if pointer capture is set for the control. </p>
<p>This returns true if <code>SetPointerCapture()</code> has been
called with <code>aCapture=ETrue</code>.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TBool</code></td>
<td class="Cell"><p class="ValueDesc"><code>ETrue</code> if the control captures the pointer,
<code>EFalse</code> if it doesn't.</p></td>
</tr>
</table></td></tr></table>
<a name="2.20.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aIgnoreEventsUntilNextPointerUp%28%29"></a>
<hr size="1" noshade>
<h3><code>IgnoreEventsUntilNextPointerUp()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void IgnoreEventsUntilNextPointerUp();</code></p><h4 class="subheading">Description</h4>
<p>Sets control to ignore pointer events until next pointer up.
</p>
<p>This means that all events until and including the next pointer
up event get thrown away and are not processed.</p>
<a name="2.21"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Control observers — sending an event to another
control</h2>
</div><div class="Bodytext">
<h4 class="subheading">Description</h4>
<p><code>MCoeControlObserver</code> defines a protocol for passing
events between controls: events are sent using
<code>CCoeControl::ReportEventL()</code>, and handled by the observer control
using <code>MCoeControlObserver::HandleControlEventL()</code>.
<code>MCoeControlObserver</code> also defines a set of event types that can be
passed between controls: these are not the same as the user input events that
are generated by the window server.</p>
<p>A control can send events to another control by making that
control its observer. To do this, the observer control must be derived from
<code>MCoeControlObserver</code>, and must be set as the control's observer by
calling <code>SetObserver()</code>.</p>
<a name="2.21.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aSetObserver%28%29"></a>
<hr size="1" noshade>
<h3><code>SetObserver()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void SetObserver(MCoeControlObserver* aObserver);</code></p><h4 class="subheading">Description</h4>
<p>Sets the control's observer.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">MCoeControlObserver* aObserver</code></td>
<td class="Cell"><p class="ValueDesc">The observer.</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aObserver%28%29"></a>
<hr size="1" noshade>
<h3><code>Observer()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>MCoeControlObserver* Observer() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the control's observer.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">MCoeControlObserver*</code></td>
<td class="Cell"><p class="ValueDesc">The control's observer.</p></td>
</tr>
</table></td></tr></table>
<a name="2.21.5"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aReportEventL%28%29"></a>
<hr size="1" noshade>
<h3><code>ReportEventL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>protected: void ReportEventL(MCoeControlObserver::TCoeEvent aEvent);</code></p><h4 class="subheading">Description</h4>
<p>Sends an event to the control's observer.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">MCoeControlObserver::TCoeEvent aEvent</code></td>
<td class="Cell"><p class="ValueDesc">The event type.</p></td>
</tr>
</table></td></tr></table>
<a name="2.22"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Control environment and contexts</h2>
</div><div class="Bodytext">
<a name="2.22.2"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aControlEnv%28%29"></a>
<hr size="1" noshade>
<h3><code>ControlEnv()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>CCoeEnv* ControlEnv() const;</code></p><h4 class="subheading">Description</h4>
<p>Gets the control environment object for this control.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">CCoeEnv*</code></td>
<td class="Cell"><p class="ValueDesc">The control's control environment object.</p></td>
</tr>
</table></td></tr></table>
<a name="2.22.3"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aGetHelpContext%28%29"></a>
<hr size="1" noshade>
<h3><code>GetHelpContext()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void GetHelpContext(TCoeHelpContext&amp; aContext) const;</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Gets the control's help context. Returns a NULL context by
default.</p>
<p>The function must be implemented in derived classes to
associate the control with a particular Help file and topic in a context
sensitive application. The implementation should set the public data members of
<code>TCoeHelpContext</code> to the required Help file UID and context
descriptor — as created using the Context-Sensitive Help Compiler.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">TCoeHelpContext&amp; aContext</code></td>
<td class="Cell"><p class="ValueDesc">The control's help context</p></td>
</tr>
</table></td></tr></table>
<a name="2.22.4"></a></div><div class="Head3">
<a name="%3a%3aCCoeControl%3a%3aControlContext%28%29"></a>
<hr size="1" noshade>
<h3><code>ControlContext()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>MCoeControlContext* ControlContext() const;</code></p><h4 class="subheading">Support</h4>
<p>Supported from 6.0
</p><h4 class="subheading">Description</h4>
<p>Gets the control context being used by this control. </p>
<p>The function does not transfer ownership to the caller.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">MCoeControlContext*</code></td>
<td class="Cell"><p class="ValueDesc">The control context.</p></td>
</tr>
</table></td></tr></table>

</div><div class="Footer">
<hr noshade size="1">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td><p class="copyrightStatement">Copyright &copy;2002&nbsp; Symbian Ltd. &nbsp; &nbsp; &nbsp;	6.1-00174
</p></td>
<td align="right"><p><a href="#_top"><img
alt="[Top]" src="../../../stock/arrow_up.gif" border="0"
align="bottom"></a></p></td>
</table>
</div>
</body>
</html>
