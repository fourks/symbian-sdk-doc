<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>CArrayFix&lt;TAny&gt;</title>
<link href="../../../stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css" media="screen"><!--
.ButtonBox { background-image: url(../../../stock/gradient.jpg); }
--></style>
</head>
<body><a name="_top"></a><a name="2"></a>
<table width="100%" border="0" cellspacing="0"
cellpadding="0"><tbody><tr><td colspan=2 class="LogoBox"><a><img
src="../../../stock/symbian.gif" alt="Symbian" width="121"
height="46" border="0"></a><img src="../../../stock/mainheading.gif"
alt=" Developer Library" height="46" width="183"></td></tr><tr><td
class="DocSetBox" width="33%">
<p><a href="../../../Product/Generic/index.html">SYMBIAN OS V6.1 EDITION FOR C++</a></p>
</td><td class="ButtonBox" align="right" width="67%">
<p><a href="../../../_index/index.html"><img
src="../../../stock/btn_index.gif" alt="[Index]" width="53"
height="22" border="0"></a> <a href="../../GlobalGlossary/index.html"><img src="../../../stock/btn_glossary.gif"
alt="[Glossary]" border="0" width="81" height="22"></a> <img src="../../../stock/btn_spacer.gif"
alt="" width="60" height="22"> <a href="CArrayFixSegTAnyClass.html"><img src="../../../stock/btn_prev.gif"
alt="[Previous]" border="0" width="85" height="22"></a> <a href="CArrayPakBaseClass.html"><img src="../../../stock/btn_next.gif" alt="[Next]"
border="0" width="58" height="22"></a></p>
</td></tr></table>
<hr noshade size="1">
<p class="breadcrumbNav">&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/index.html">Symbian&nbsp;OS&nbsp;v6.1&nbsp;Edition&nbsp;for&nbsp;C++</a>&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/APIReference/index.html">API&nbsp;Reference</a>&nbsp;<span class="separator">&#187;</span>
<a href="index.html">Dynamic&nbsp;Arrays</a>&nbsp;<span class="separator">&#187;</span>
CArrayFix&lt;TAny&gt;</p>

<hr noshade size="1">
<div class="AuthoredContent">

<p>Location:
<code> e32base.h </code>
<br>Link against: <code> euser.lib </code>
</p>
</div><div class="Head1">
<a name="%3a%3aCArrayFix%3cTAny%3e"></a>

<h1>Class <code>CArrayFix&lt;TAny&gt;</code></h1>
</div><div class="Bodytext"><p class="Prototype"><code>CArrayFix&lt;TAny&gt;</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>A template specialisation base class for arrays of fixed length
untyped objects. The public functions provide standard array behaviour.</p>
<p>The class is always derived from and is never instantiated
explicitly.</p>
<h4 class="subheading">Derivation</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr><td class="Cell"><code>CArrayFix&lt;TAny&gt;</code></td><td class="Cell">A template specialisation base class for arrays of fixed length untyped objects</td>
</tr>
<tr><td class="Cell"><code><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase">CArrayFixBase</a></code></td><td class="Cell">Base class for arrays of fixed length objects</td>
</tr>
<tr><td class="Cell"><code><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase">CBase</a></code></td><td class="Cell">Base class for all classes to be instantiated on the heap</td>
</tr>
</table></td></tr></table>
<p>Defined in <code>CArrayFix<TAny></code>:
<br><code class="ApiItem"><a href="CArrayFixTAnyClass.html#%3a%3aCArrayFix%3cTAny%3e%3a%3aAppendL%28%29" title="Appends the specified untyped element onto the end of the array">AppendL()</a></code>, <code class="ApiItem"><a href="CArrayFixTAnyClass.html#%3a%3aCArrayFix%3cTAny%3e%3a%3aAppendL%28%29Append" title="Appends one or more untyped elements onto the end of the array">AppendL()Append</a></code>, <code class="ApiItem"><a href="CArrayFixTAnyClass.html#%3a%3aCArrayFix%3cTAny%3e%3a%3aAt%28%29" title="Returns a pointer to the untyped element located at the specified position within the array">At()</a></code>, <code class="ApiItem"><a href="CArrayFixTAnyClass.html#%3a%3aCArrayFix%3cTAny%3e%3a%3aBack%28%29" title="Returns a pointer to the beginning of a contiguous region">Back()</a></code>, <code class="ApiItem"><a href="CArrayFixTAnyClass.html#%3a%3aCArrayFix%3cTAny%3e%3a%3aEnd%28%29" title="Returns a pointer to the first byte following the end of the contiguous region containing the element at the specfied position within the array">End()</a></code>, <code class="ApiItem"><a href="CArrayFixTAnyClass.html#%3a%3aCArrayFix%3cTAny%3e%3a%3aExtendL%28%29" title="Expands the array by the length of one element at the end of the array and returns a pointer to this new location">ExtendL()</a></code>
</p>
<p>Inherited from <code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase" title="Base class for arrays of fixed length objects">CArrayFixBase</a></code>:
<br><code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase%3a%3aCompress%28%29" title="Compresses the array">Compress()</a></code>,
<code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase%3a%3aCount%28%29" title="Returns the number of elements held in the array">Count()</a></code>,
<code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase%3a%3aDelete%28%29" title="Delete elements by position">Delete()</a></code>,
<code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase%3a%3aLength%28%29" title="Returns the length of an element">Length()</a></code>,
<code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase%3a%3aReset%28%29" title="Resets the array">Reset()</a></code>,
<code class="ApiItem"><a href="CArrayFixBaseClass.html#%3a%3aCArrayFixBase%3a%3aSort%28%29" title="Sorts the elements of the array into key sequence">Sort()</a></code></p>
<p>Inherited from <code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase" title="Base class for all classes to be instantiated on the heap">CBase</a></code>:
<br><code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase%3a%3aoperator%20new%28%29" title="Allocates the object from the heap and then initialises its contents to binary zeroes">operator new()</a></code></p>
<a name="dynamicarrays%2eCArrayFixTAny%2eappend"></a>
</div><div class="Head2">
<hr size="2" noshade>
<h2>Appending elements</h2>
</div><div class="Bodytext">
<a name="2.6.3"></a></div><div class="Head3">
<a name="%3a%3aCArrayFix%3cTAny%3e%3a%3aAppendL%28%29"></a>
<hr size="1" noshade>
<h3><code>AppendL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void AppendL(const TAny* aPtr);</code></p><h4 class="subheading">Description</h4>
<p>Appends the specified untyped element onto the end of the
array.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aPtr </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to an untyped element to be appended. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">The function may attempt to expand the array buffer. If
there is insufficient memory available, the function leaves. The leave code is
one of the system wide error codes. If the function leaves, the array is left
in the state it was in before the call. </p></td>
</tr>
</table></td></tr></table>
<a name="2.6.4"></a></div><div class="Head3">
<a name="%3a%3aCArrayFix%3cTAny%3e%3a%3aAppendL%28%29Append"></a>
<hr size="1" noshade>
<h3><code>AppendL()Append</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void AppendL(const TAny* aPtr,TInt aCount);</code></p><h4 class="subheading">Description</h4>
<p>Appends one or more untyped elements onto the end of the
array.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aPtr </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first of the contiguous untyped elements to
be appended. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aCount </code></td>
<td class="Cell"><p class="ValueDesc"> The number of contiguous elements located at <code>aPtr</code>
to be appended. The value must not be negative otherwise the function raises an
E32USER-CBase 23 panic. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">The function may attempt to expand the array buffer. If there
is insufficient memory available, the function leaves. The leave code is one of
the system wide error codes. If the function leaves, the array is left in the
state it was in before the call. </p></td>
</tr>
</table></td></tr></table>
<a name="dynamicarrays%2eCArrayFixTAny%20expand"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Expanding the array</h2>
</div><div class="Bodytext">
<a name="2.7.3"></a></div><div class="Head3">
<a name="%3a%3aCArrayFix%3cTAny%3e%3a%3aExtendL%28%29"></a>
<hr size="1" noshade>
<h3><code>ExtendL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TAny* ExtendL();</code></p><h4 class="subheading">Description</h4>
<p>Expands the array by the length of one element at the end of the
array and returns a pointer to this new location.</p>
<p>As elements are untyped, no construction is possible and the
content of the new location remains undefined.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the new element location at the end of the array.
</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">The function may attempt to expand the array buffer. If there
is insufficient memory available, the function leaves. The leave code is one of
the system wide error codes. If the function leaves, the array is left in the
state it was in before the call. </p></td>
</tr>
</table></td></tr></table>
<a name="dynamicarrays%2eCArrayFixTAny%20indexing"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Indexing into the array</h2>
</div><div class="Bodytext">
<a name="2.8.3"></a></div><div class="Head3">
<a name="%3a%3aCArrayFix%3cTAny%3e%3a%3aAt%28%29"></a>
<hr size="1" noshade>
<h3><code>At()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>const TAny* At(TInt anIndex) const;<br>TAny* At(TInt anIndex);</code></p><h4 class="subheading">Description</h4>
<p>Returns a pointer to the untyped element located at the specified
position within the array.</p>
<p>Two versions of the function are supplied. The compiler chooses the
appropriate version based on the use made of the returned reference. If the
returned reference is used in an expression where that reference can be
modified, then the non-const version is chosen.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt anIndex </code></td>
<td class="Cell"><p class="ValueDesc"> The position of the element within the array. The position is
relative to zero; i.e. zero implies the first element in the array. This value
must be non-negative and less than the number of objects currently within the
array otherwise the functions raise an E32User-CBase 21 panic. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* </code></td>
<td class="Cell"><p class="ValueDesc"> A non-const pointer to the untyped element located at position
<code>anIndex</code> within the array. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* </code></td>
<td class="Cell"><p class="ValueDesc"> A const pointer to the untyped element located at position
<code>anIndex</code> within the array. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8.4"></a></div><div class="Head3">
<a name="%3a%3aCArrayFix%3cTAny%3e%3a%3aEnd%28%29"></a>
<hr size="1" noshade>
<h3><code>End()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>const T* End(TInt anIndex) const;<br>T* End(TInt anIndex);</code></p><h4 class="subheading">Description</h4>
<p>Returns a pointer to the first byte following the end of the
contiguous region containing the element at the specfied position within the
array.</p>
<p>For flat buffers, the pointer always points to the first byte
following the end of the buffer.</p>
<p>For segmented buffers, the pointer always points to the first byte
following the end of the segment which contains the element.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt anIndex </code></td>
<td class="Cell"><p class="ValueDesc"> The position of the element within the array. The position is
relative to zero; i.e. zero implies the first element in the array. This value
must be non-negative and less than the number of objects currently within the
array otherwise the operators raise an E32USER-CBase 21 panic. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> T* </code></td>
<td class="Cell"><p class="ValueDesc"> A non-const pointer to the byte following the end of the contiguous
region. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const T* </code></td>
<td class="Cell"><p class="ValueDesc"> A const pointer to the byte following the end of the contiguous
region. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8.5"></a></div><div class="Head3">
<a name="%3a%3aCArrayFix%3cTAny%3e%3a%3aBack%28%29"></a>
<hr size="1" noshade>
<h3><code>Back()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>const T* Back(TInt anIndex) const;<br>T* Back(TInt anIndex);</code></p><h4 class="subheading">Description</h4>
<p>Returns a pointer to the beginning of a contiguous region.</p>
<p>For flat buffers, the function always returns a pointer to the
beginning of the buffer.</p>
<p>For segmented buffers, the function returns a pointer to the beginning
of the segment for all elements in that segment except the first. If the
element at the specified position is the first in a segment, then the function
returns a pointer the beginning of the previous segment.</p>
<p>For the first element in the array, the function returns a NULL
pointer.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt anIndex </code></td>
<td class="Cell"><p class="ValueDesc"> The position of the element within the array. The position is relative
to zero; i.e. zero implies the first element in the array. This value must be
non-negative and less than the number of objects currently within the array
otherwise the operators raise an E32User-CBase 21 panic. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> T* </code></td>
<td class="Cell"><p class="ValueDesc"> A non-const pointer to the beginning of the contiguous region. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const T* </code></td>
<td class="Cell"><p class="ValueDesc"> A const pointer to the beginning ofd the contiguous region. </p></td>
</tr>
</table></td></tr></table>

</div><div class="Footer">
<hr noshade size="1">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td><p class="copyrightStatement">Copyright &copy;2002&nbsp; Symbian Ltd. &nbsp; &nbsp; &nbsp;	6.1-00174
</p></td>
<td align="right"><p><a href="#_top"><img
alt="[Top]" src="../../../stock/arrow_up.gif" border="0"
align="bottom"></a></p></td>
</table>
</div>
</body>
</html>
