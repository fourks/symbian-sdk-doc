<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>Mem</title>
<link href="../../../_stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css" media="screen"><!--
.ButtonBox { background-image: url(../../../_stock/gradient.jpg); }
--></style>
</head>
<body><a name="_top"></a><a name="2"></a>
<table width="100%" border="0" cellspacing="0"
cellpadding="0"><tbody><tr><td colspan=2 class="LogoBox"><a><img
src="../../../_stock/symbian.gif" alt="Symbian" width="121"
height="46" border="0"></a><img src="../../../_stock/mainheading.gif"
alt=" Developer Library" height="46" width="183"></td></tr><tr><td
class="DocSetBox" width="33%">
<p><a href="../../../Product/Generic/index.html">SYMBIAN OS V6.1 EDITION FOR C++</a></p>
</td><td class="ButtonBox" align="right" width="67%">
<p><a href="../../../_index/index.html"><img
src="../../../_stock/btn_index.gif" alt="[Index]" width="53"
height="22" border="0"></a> <a href="../../GlobalGlossary/index.html"><img src="../../../_stock/btn_glossary.gif"
alt="[Glossary]" border="0" width="81" height="22"></a> <img src="../../../_stock/btn_spacer.gif"
alt="" width="60" height="22"> <a href="AboutRawMemory.guide.html"><img src="../../../_stock/btn_prev.gif"
alt="[Previous]" border="0" width="85" height="22"></a> <a href="RawMemorySeeAlso.guide.html"><img src="../../../_stock/btn_next.gif" alt="[Next]"
border="0" width="58" height="22"></a></p>
</td></tr></table>
<hr noshade size="1">
<p class="breadcrumbNav">&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/index.html">Symbian&nbsp;OS&nbsp;v6.1&nbsp;Edition&nbsp;for&nbsp;C++</a>&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/APIReference/index.html">API&nbsp;Reference</a>&nbsp;<span class="separator">&#187;</span>
<a href="index.html">Raw&nbsp;Memory</a>&nbsp;<span class="separator">&#187;</span>
Mem</p>

<hr noshade size="1">
<div class="AuthoredContent">

<p>Location:
<code> e32std.h </code>
<br>Link against: <code> euser.lib </code>
</p>
</div><div class="Head1">
<a name="%3a%3aMem"></a>

<h1>Class <code>Mem</code></h1>
</div><div class="Bodytext"><p class="Prototype"><code>Mem</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Contains a set of static functions which perform manipulation of
data in memory.</p>
<p>The arguments passed to the functions of this class are pointers to
memory locations and length values. These functions are, therefore, not
normally used in open code but are suitable for implementing data manipulation
for other classes. Typically the interface provided by such classes is typesafe
and hides this direct memory to memory manipulation.</p>
<p>Defined in <code>Mem</code>:
<br><code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationMethodById%28%29" title="Returns the collation method identified by the specified Uid">CollationMethodById()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationMethodByIndex%28%29" title="Returns the collation method identified by the specified index">CollationMethodByIndex()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationMethodId%28%29" title="Returns the Uid associated with the specified collation method">CollationMethodId()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationMethods%28%29" title="Returns the number of collation methods in this locale">CollationMethods()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationRuleSetById%28%29" title="Returns the collation rule set identified by the specified Uid">CollationRuleSetById()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationRuleSetByIndex%28%29" title="Returns the collation rule set identified by the specified index">CollationRuleSetByIndex()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationRuleSetId%28%29" title="Returns the Uid associated with the specified collation rule set in this locale's collation repertoire">CollationRuleSetId()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCollationRuleSets%28%29" title="Returns the number of collation rule sets in this locale's collation repertoire">CollationRuleSets()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCompare%28%29" title="Compares a block of data at one specified location with a block of data at another specified location">Compare()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCompareC%28%29" title="Compares a block of data at one location with a block of data at another location using the specified collation method and collating to the specified maximum collation level">CompareC()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCompareF%28%29" title="Compares a block of data at one specified location with a block of data at another specified location, using the standard folding method appropriate to the current locale">CompareF()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCopy%28%29" title="Copies data from a source location to a target location and returns a pointer to the end of the copied data">Copy()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aCrc%28%29" title="Performs a CCITT CRC checksum on the specified data">Crc()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aFill%28%29" title="Fills a specified block of data with a specified character, replacing any existing content">Fill()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aFillZ%28%29" title="Fills a specified block of data with binary zeroes (i.e">FillZ()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aMove%28%29" title="Moves a block of data from a source location to a target location and returns a pointer to the end of the moved data">Move()</a></code>, <code class="ApiItem"><a href="MemClass.html#%3a%3aMem%3a%3aSwap%28%29" title="Swaps a number of bytes of data between two specified locations">Swap()</a></code>
</p>
<a name="2.5"></a>
</div><div class="Head2">
<hr size="2" noshade>
<h2>Copying, moving and swapping data</h2>
</div><div class="Bodytext">
<a name="2.5.2"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCopy%28%29"></a>
<hr size="1" noshade>
<h3><code>Copy()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TUint8* Copy(TAny* aTrg,const TAny* aSrc,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Copies data from a source location to a target location and
returns a pointer to the end of the copied data. The source and target areas
can overlap.</p>
<p>The copy operation is optimised so that if both source and
target locations are aligned on a word boundary, the operation performs the
copy on a word by word basis.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* aTrg </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the target location for the copy operation.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aSrc </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the source location for the copy operation.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes to be copied. This value must not be
negative. In debug builds only, a negative value causes the function to raise a
USER 90 panic. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint8* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to a location <code>aLength</code> bytes beyond
<code>aTrg</code> (i.e. the location <code>aTrg</code>+<code>aLength</code>).
</p></td>
</tr>
</table></td></tr></table>
<a name="2.5.3"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aMove%28%29"></a>
<hr size="1" noshade>
<h3><code>Move()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TUint8* Move(TAny* aTrg,const TAny* aSrc,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Moves a block of data from a source location to a target location
and returns a pointer to the end of the moved data. The source and target areas
can overlap.</p>
<p>Both source and target locations must be aligned on a word
boundary. The specified length must also be a multiple of 4.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* aTrg </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the target location for the move operation. This
pointer must be word aligned. In debug builds only, the function raises a USER
93 panic if the pointer is not word aligned. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aSrc </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the source location for the move operation. This
pointer must be word aligned. In debug builds only, the function raises a USER
92 panic if the pointer is not word aligned. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes to be copied. This value must be a multiple
of 4. In debug builds only, the function raises a USER 91 panic if this value
is not a multiple of 4. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint8* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to a location <code>aLength</code> bytes beyond
<code>aTrg</code> (i.e. the location <code>aTrg</code>+<code>aLength</code>).
</p></td>
</tr>
</table></td></tr></table>
<a name="2.5.4"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aSwap%28%29"></a>
<hr size="1" noshade>
<h3><code>Swap()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static void Swap(TAny* aPtr1,TAny* aPtr2,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Swaps a number of bytes of data between two specified locations.
The source and target areas can overlap.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* aPtr1 </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first location taking part in the swap. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* aPtr2 </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to second location taking part in the swap. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes to be swapped between the two locations. This
value must not be negative. In debug builds only, the function raises a USER 94
panic if this value is negative. </p></td>
</tr>
</table></td></tr></table>
<a name="2.6"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Filling memory</h2>
</div><div class="Bodytext">
<a name="2.6.2"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aFill%28%29"></a>
<hr size="1" noshade>
<h3><code>Fill()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static void Fill(TAny* aTrg,TInt aLength,TChar aChar);</code></p><h4 class="subheading">Description</h4>
<p>Fills a specified block of data with a specified character, replacing
any existing content. The function assumes that the fill character is a
non-Unicode character.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* aTrg </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the location where filling is to start. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes to be filled. This value must not be negative.
In debug builds only, the function raises a USER 95 panic if this value is
negative. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TChar aChar </code></td>
<td class="Cell"><p class="ValueDesc"> The fill character. </p></td>
</tr>
</table></td></tr></table>
<a name="2.6.3"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aFillZ%28%29"></a>
<hr size="1" noshade>
<h3><code>FillZ()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static void FillZ(TAny* aTrg,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Fills a specified block of data with binary zeroes (i.e. 0x00),
replacing any existing content.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TAny* aTrg </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the location where filling is to start. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes to be filled. This value must not be negative. In
debug builds only, the function raises a USER 95 panic if this value is
negative. </p></td>
</tr>
</table></td></tr></table>
<a name="2.7"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Calculate a checksum</h2>
</div><div class="Bodytext">
<a name="2.7.2"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCrc%28%29"></a>
<hr size="1" noshade>
<h3><code>Crc()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static void Crc(TUint16&amp; aCrc,const TAny* aPtr,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Performs a CCITT CRC checksum on the specified data.</p>
<p>On return from this function, the referenced 16 bit integer contains the
checksummed value.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint16&amp; aCrc </code></td>
<td class="Cell"><p class="ValueDesc"> A reference to a 16 bit integer to contain the checksummed value.
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aPtr </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the start of the data to be checksummed. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the data to be checksummed. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Comparison of data</h2>
</div><div class="Bodytext">
<a name="2.8.2"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCompare%28%29"></a>
<hr size="1" noshade>
<h3><code>Compare()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt Compare(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);<br>static TInt Compare(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);</code></p><h4 class="subheading">Description</h4>
<p>Compares a block of data at one specified location with a block of data
at another specified location. Data is interpreted as being either 8 bit data
or 16 bit data, depending on the specific overloaded function.</p>
<p>For the 8 bit function, the comparison proceeds on a byte for byte basis.
The result of the comparison is based on the difference of the first bytes to
disagree.</p>
<p>For the 16 bit function, the comparison proceeds on a double-byte for
double byte basis. The result of the comparison is based on the difference of
the first pair of bytes to disagree.</p>
<p>For both functions, the data at the two locations are equal if they have
the same length and content. Where the lengths are different and the shorter
section of data is the same as the first part of the longer section of data,
the shorter is considered to be less than the longer.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint8* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 8 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the first (or left) block of data to be compared. In the 8
bit function, this is the number of bytes. In the 16 bit function, this is the
number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint8* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 8 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aRightL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the second (or right) block of data to be compared. In the
8 bit function, this is the number of bytes. In the 16 bit function, this is
the number of double-bytes. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> Positive, if the first (or left) block of data is greater than the
second (or right) block of data. Negative, if the first (or left) block of data
is less than the second (or right) block of data. Zero, if both the first (or
left) and second (or right) blocks of data have the same length and the same
content. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8.3"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCompareF%28%29"></a>
<hr size="1" noshade>
<h3><code>CompareF()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CompareF(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);<br>static TInt CompareF(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);</code></p><h4 class="subheading">Description</h4>
<p>Compares a block of data at one specified location with a block of data
at another specified location, using the standard folding method appropriate to
the current locale. Data is interpreted as being either 8 bit data or 16 bit
data, depending on the specific overloaded function.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint8* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 8 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the first (or left) block of data to be compared. In the 8
bit function, this is the number of bytes. In the 16 bit function, this is the
number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint8* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 8 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aRightL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the second (or right) block of data to be compared. In the
8 bit function, this is the number of bytes. In the 16 bit function, this is
the number of double-bytes. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> Positive, if the first (or left) block of data is greater than the
second (or right) block of data. Negative, if the first (or left) block of data
is less than the second (or right) block of data. Zero, if both the first (or
left) and second (or right) blocks of data have the same length and the same
content. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="MemClass.html#%3a%3aMem%3a%3aCompare%28%29" title="Compares a block of data at one specified location with a block of data at another specified location"><code class="ApiItem">Mem::Compare()</code></a></li>
</ul>
<a name="2.8.4"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCompareC%28%29"></a>
<hr size="1" noshade>
<h3><code>CompareC()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CompareC(const TUint8* aLeft,TInt aLeftL,const TUint8* aRight,TInt aRightL);<br>static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
<br>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Compares a block of data at one specified location with a block of data
at another specified location using the standard collation method appropriate
to the current locale. Data is interpreted as being either 8 bit data or 16 bit
data, depending on the specific overloaded function.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint8* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 8 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the first (or left) block of data to be compared. In the 8
bit function, this is the number of bytes. In the 16 bit function, this is the
number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint8* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 8 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aRightL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the second (or right) block of data to be compared. In the
8 bit function, this is the number of bytes. In the 16 bit function, this is
the number of double-bytes. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> Positive, if the first (or left) block of data is greater than the
second (or right) block of data. Negative, if the first (or left) block of data
is less than the second (or right) block of data. Zero, if both the first (or
left) and second (or right) blocks of data have the same length and the same
content. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="MemClass.html#%3a%3aMem%3a%3aCompare%28%29" title="Compares a block of data at one specified location with a block of data at another specified location"><code class="ApiItem">Mem::Compare()</code></a></li>
</ul>
<a name="2.8.5"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCompareC%28%29"></a>
<hr size="1" noshade>
<h3><code>CompareC()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL,const TInt16* aCollationRules);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
</p><h4 class="subheading">Description</h4>
<p>Compares a block of data at one specified location with a block of data
at another specified location using the specified collation rule set.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the first (or left) block of data to be compared. This is
the number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aRightL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the second (or right) block of data to be compared. This
is the number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TInt16* aCollationRules </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the collation rule set. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> Positive, if the first (or left) block of data is greater than the
second (or right) block of data. Negative, if the first (or left) block of data
is less than the second (or right) block of data. Zero, if both the first (or
left) and second (or right) blocks of data have the same length and the same
content. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">See also:</h4>
<ul>
<li><a href="MemClass.html#%3a%3aMem%3a%3aCompare%28%29" title="Compares a block of data at one specified location with a block of data at another specified location"><code class="ApiItem">Mem::Compare()</code></a></li>
</ul>
<a name="2.8.6"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCompareC%28%29"></a>
<hr size="1" noshade>
<h3><code>CompareC()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL,TUint32 aDesiredCollationRulesId,TUint32&amp; aActualCollationRulesId);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
<br>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Compares a block of data at one specified location with a block of data
at another specified location using the collation rule set associated with the
specified Uid. If no collation rule set with the specified Uid can be found,
the function uses a default collation rule set and returns its associated
Uid.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the first (or left) block of data to be compared. This is
the number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aRightL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the second (or right) block of data to be compared. This
is the number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint32 aDesiredCollationRulesId </code></td>
<td class="Cell"><p class="ValueDesc"> The Uid of the collation rule set required. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint32&amp; aActualCollationRulesId </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the Uid of the collation rule set used. This may be
different from the specified Uid, if there is no collation rule set with that
Uid. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> Positive, if the first (or left) block of data is greater than the
second (or right) block of data. Negative, if the first (or left) block of data
is less than the second (or right) block of data. Zero, if both the first (or
left) and second (or right) blocks of data have the same length and the same
content. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8.7"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCompareC%28%29"></a>
<hr size="1" noshade>
<h3><code>CompareC()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CompareC(const TUint16* aLeft,TInt aLeftL,const TUint16* aRight,TInt aRightL, TInt aMaxLevel,const TCollationMethod* aCollationMethod);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.0
<br>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Compares a block of data at one location with a block of data at another
location using the specified collation method and collating to the specified
maximum collation level. If no collation method is supplied, a default method,
appropriate to the current locale, is used.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aLeft </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the first (or left) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLeftL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the first (or left) block of data to be compared. This is
the number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TUint16* aRight </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the second (or right) block of 16 bit data to be
compared.</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aRightL </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the second (or right) block of data to be compared. This
is the number of double-bytes. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aMaxLevel </code></td>
<td class="Cell"><p class="ValueDesc"> The maximum collation level. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TCollationMethod* aCollationMethod </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the collation method or <code>NULL</code>. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> Positive, if this descriptor is greater than the specified descriptor.
Negative, if this descriptor is less than the specified descriptor. Zero, if
both descriptors have the same length and the their contents are the
same.</p></td>
</tr>
</table></td></tr></table>
<a name="2.9"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Collation methods</h2>
</div><div class="Bodytext">
<a name="2.9.2"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationMethods%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationMethods()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CollationMethods();</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.0
<br>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Returns the number of collation methods in this locale.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of collation methods. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.3"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationMethodId%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationMethodId()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TUint CollationMethodId(TInt aIndex);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.0
<br>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Returns the Uid associated with the specified collation method.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aIndex </code></td>
<td class="Cell"><p class="ValueDesc"> An index into the set of collation methods in thie locale. This value is
relative to zero; i.e. a zero value refers to the first collation method. This
value: must not be negative, must be less than the total number of collation
methods in this locale.<!--<listitem style="list bullet">must not be negative</listitem>
<listitem style="list bullet">must be less than the total number of collation methods in this locale.</listitem>
-->In debug builds only, the function raises a USER 132 panic if these
conditions are false. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint </code></td>
<td class="Cell"><p class="ValueDesc"> The Uid of the collation method </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.4"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationMethodByIndex%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationMethodByIndex()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static const TCollationMethod* CollationMethodByIndex(TInt aIndex);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.0
<br>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Returns the collation method identified by the specified index.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aIndex </code></td>
<td class="Cell"><p class="ValueDesc"> An index into the set of collation methods in this locale. This value is
relative to zero; i.e. a zero value refers to the first collation method. This
value: must not be negative, must be less than the total number of collation
methods in this locale.<!--<listitem style="list bullet">must not be negative</listitem>
<listitem style="list bullet">must be less than the total number of collation methods in this locale.</listitem>
-->In debug builds only, the function raises a USER 132 panic if these
conditions are false. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TCollationMethod* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the collation method. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.5"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationMethodById%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationMethodById()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static const TCollationMethod* CollationMethodById(TUint aId);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.0
<br>Supported from 5.1
</p><h4 class="subheading">Description</h4>
<p>Returns the collation method identified by the specified Uid.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint aId </code></td>
<td class="Cell"><p class="ValueDesc"> The Uid of a collation method in the set of collation methods in this
locale. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TCollationMethod* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the collation method. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.6"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationRuleSets%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationRuleSets()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CollationRuleSets();</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
<br>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Returns the number of collation rule sets in this locale's collation
repertoire.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of collation rule sets. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.7"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationRuleSetId%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationRuleSetId()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static TInt CollationRuleSetId(TInt aIndex);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
<br>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Returns the Uid associated with the specified collation rule set in this
locale's collation repertoire.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aIndex </code></td>
<td class="Cell"><p class="ValueDesc"> An index into the collection of collation rule sets in this locale's
collation repertoire. This value is relative to zero; i.e. a zero value refers
to the first rule set. This value: must not be negative, must be less than the
total number of rule sets.<!--<listitem style="list bullet">must not be negative</listitem>
<listitem style="list bullet">must be less than the total number of rule sets.</listitem>
-->In debug builds only, the function raises a USER 132 panic if these
conditions are false. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The Uid of the collation rule set. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.8"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationRuleSetByIndex%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationRuleSetByIndex()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static const TInt16* CollationRuleSetByIndex(TInt aIndex);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
<br>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Returns the collation rule set identified by the specified index.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aIndex </code></td>
<td class="Cell"><p class="ValueDesc"> An index into the collection of collation rule sets in this locale's
collation repertoire. This value is relative to zero; i.e. a zero value refers
to the first rule set. This value: must not be negative, must be less than the
total number of rule sets.<!--<listitem style="list bullet">must not be negative</listitem>
<listitem style="list bullet">must be less than the total number of rule sets.</listitem>
-->In debug builds only, the function raises a USER 132 panic if these
conditions are false. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt16* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the collation rule set. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.9"></a></div><div class="Head3">
<a name="%3a%3aMem%3a%3aCollationRuleSetById%28%29"></a>
<hr size="1" noshade>
<h3><code>CollationRuleSetById()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>static const TInt16* CollationRuleSetById(TUint32 aDesiredId,TUint32&amp; aActualId);</code></p><h4 class="subheading">Support</h4>
<p>Withdrawn in 5.1
<br>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Returns the collation rule set identified by the specified Uid. If no
collation rule set with the specified Uid can be found, the function returns a
default collation rule set and its associated Uid.</p>
<p>This function is only defined for 16 bit (Unicode) build variants. This
means that the function is not defined for 8 bit build variants, even when an
explicit 16 bit descriptor is used.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint32 aDesiredId </code></td>
<td class="Cell"><p class="ValueDesc"> The Uid of the collation rule set required in this locale's collation
repertoire. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TUint32&amp; aActualId </code></td>
<td class="Cell"><p class="ValueDesc"> On return, contains the Uid of the returned collation rule set. This may
be different from the specified Uid, if there is no collation rule set with
that Uid. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt16* </code></td>
<td class="Cell"><p class="ValueDesc"> A pointer to the collation rule set. </p></td>
</tr>
</table></td></tr></table>

</div><div class="Footer">
<hr noshade size="1">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td><p class="copyrightStatement">Copyright &copy;2002&nbsp; Symbian Ltd. &nbsp; &nbsp; &nbsp;	6.1-00174
</p></td>
<td align="right"><p><a href="#_top"><img
alt="[Top]" src="../../../_stock/arrow_up.gif" border="0"
align="bottom"></a></p></td>
</table>
</div>
</body>
</html>
