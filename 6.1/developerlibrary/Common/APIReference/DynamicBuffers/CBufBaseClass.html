<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>CBufBase</title>
<link href="../../../_stock/sysdoc.css" type="text/css" rel="stylesheet" media="screen">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css" media="screen"><!--
.ButtonBox { background-image: url(../../../_stock/gradient.jpg); }
--></style>
</head>
<body><a name="_top"></a><a name="2"></a>
<table width="100%" border="0" cellspacing="0"
cellpadding="0"><tbody><tr><td colspan=2 class="LogoBox"><a><img
src="../../../_stock/symbian.gif" alt="Symbian" width="121"
height="46" border="0"></a><img src="../../../_stock/mainheading.gif"
alt=" Developer Library" height="46" width="183"></td></tr><tr><td
class="DocSetBox" width="33%">
<p><a href="../../../Product/Generic/index.html">SYMBIAN OS V6.1 EDITION FOR C++</a></p>
</td><td class="ButtonBox" align="right" width="67%">
<p><a href="../../../_index/index.html"><img
src="../../../_stock/btn_index.gif" alt="[Index]" width="53"
height="22" border="0"></a> <a href="../../GlobalGlossary/index.html"><img src="../../../_stock/btn_glossary.gif"
alt="[Glossary]" border="0" width="81" height="22"></a> <img src="../../../_stock/btn_spacer.gif"
alt="" width="60" height="22"> <a href="AboutDynamicBuffers.guide.html"><img src="../../../_stock/btn_prev.gif"
alt="[Previous]" border="0" width="85" height="22"></a> <a href="CBufFlatClass.html"><img src="../../../_stock/btn_next.gif" alt="[Next]"
border="0" width="58" height="22"></a></p>
</td></tr></table>
<hr noshade size="1">
<p class="breadcrumbNav">&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/index.html">Symbian&nbsp;OS&nbsp;v6.1&nbsp;Edition&nbsp;for&nbsp;C++</a>&nbsp;<span class="separator">&#187;</span>
<a href="../../../Product/Generic/APIReference/index.html">API&nbsp;Reference</a>&nbsp;<span class="separator">&#187;</span>
<a href="index.html">Dynamic&nbsp;Buffers</a>&nbsp;<span class="separator">&#187;</span>
CBufBase</p>

<hr noshade size="1">
<div class="AuthoredContent">

<p>Location:
<code> e32base.h </code>
<br>Link against: <code> euser.lib </code>
</p>
</div><div class="Head1">
<a name="%3a%3aCBufBase"></a>

<h1>Class <code>CBufBase</code></h1>
</div><div class="Bodytext"><p class="Prototype"><code>CBufBase</code></p><h4 class="subheading">Support</h4>
<p>Supported from 5.0
</p><h4 class="subheading">Description</h4>
<p>Specifies the interface for dynamic buffers. Functions are grouped
into several categories:</p>
<ul>
<li>
<p>the basic functions, <code>InsertL()</code>,
<code>Read()</code>, <code>Write()</code>, <code>Delete()</code>,
<code>Reset()</code> and <code>Size()</code>, transfer data between the buffer
and other places, and allow that data to be deleted</p>
</li>
<li>
<p>the <code>ExpandL()</code> and <code>Resize()</code> functions
allow some operations to be carried out with greater efficiency</p>
</li>
<li>
<p>a <code>Compress()</code> function frees (back to the heap) any
space which may have been allocated, but not used</p>
</li>
<li>
<p><code>Ptr()</code> and <code>BackPtr()</code> allow look-up of
contiguous data from any given position, forward or backward</p>
</li>
</ul>
<p>In addition, important information is maintained in data
members.</p>
<h4 class="subheading">Derivation</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr><td class="Cell"><code><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase">CBase</a></code></td><td class="Cell">Base class for all classes to be instantiated on the heap</td>
</tr>
<tr><td class="Cell"><code>CBufBase</code></td><td class="Cell">Specifies the interface for dynamic buffers</td>
</tr>
</table></td></tr></table>
<p>Defined in <code>CBufBase</code>:
<br><code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aBackPtr%28%29" title="Returns a pointer descriptor which refers to data from just before the specified data byte backward until the beginning of the contiguous region containing that byte">BackPtr()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aCompress%28%29" title="Compresses the buffer so as to occupy minimal space">Compress()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aDelete%28%29" title="Deletes data from the buffer">Delete()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aExpandL%28%29" title="Inserts an uninitialised region into the buffer">ExpandL()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aInsertL%28%29" title="Inserts data into the buffer -- overloaded function">InsertL()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aPtr%28%29" title="Returns a pointer descriptor which refers to all from the specified data byte until the end of the contiguous region containing that byte">Ptr()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aRead%28%29" title="Reads data from the buffer into a descriptor -- overloaded function">Read()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aReset%28%29" title="Deletes all data in the buffer">Reset()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aResizeL%28%29" title="Re-sizes the buffer to the specified size">ResizeL()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aSize%28%29" title="Returns the number of data bytes in the buffer">Size()</a></code>, <code class="ApiItem"><a href="CBufBaseClass.html#%3a%3aCBufBase%3a%3aWrite%28%29" title="Writes data from a descriptor to the buffer -- overloaded function">Write()</a></code>
</p>
<p>Inherited from <code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase" title="Base class for all classes to be instantiated on the heap">CBase</a></code>:
<br><code class="ApiItem"><a href="../BasicTypes/CBaseClass.html#%3a%3aCBase%3a%3aoperator%20new%28%29" title="Allocates the object from the heap and then initialises its contents to binary zeroes">operator new()</a></code></p>
<a name="2.6"></a>
</div><div class="Head2">
<hr size="2" noshade>
<h2>Basic functions</h2>
</div><div class="Bodytext">
<a name="2.6.2"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aInsertL%28%29"></a>
<hr size="1" noshade>
<h3><code>InsertL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void InsertL(TInt aPos,const TDesC8&amp; aDes);<br>void InsertL(TInt aPos,const TDesC8&amp; aDes,TInt aLength);<br>void InsertL(TInt aPos,const TAny* aPtr,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Inserts data into the buffer&nbsp;&#8212; overloaded
function. Data at and beyond the insertion position is moved to make way for
the inserted data. Data before the insertion position remains in place.</p>
<p>Notes:</p>
<ul>
<li>
<p>Insertion may require more buffer space to be
allocated.</p>
</li>
<li>
<p>In the case of flat buffers, the buffer is extended by a
<code>ReAllocL()</code> of the buffer&#8217;s heap cell, to the smallest
multiple of the granularity that will contain the data required. If this
reallocation fails, the insertion is impossible and a leave occurs.</p>
</li>
<li>
<p>In the case of segmented buffers, a reallocation is
performed if the segment containing the insertion position has insufficient
space, and immediately-neighbouring segments cannot be used to contain the new
data. As many new segments as are necessary to contain the inserted data are
allocated. Each new segment&#8217;s length is the buffer&#8217;s granularity.
If extension or new allocation fails, a leave occurs.</p>
</li>
<li>
<p>Insertion may also require data to be shuffled. In the case
of flat buffers, data beyond the insertion point is shuffled up to create a
gap: the new data is then inserted into this gap. In the case of segmented
buffers, shuffling is minimised by inserting the new data into newly-allocated
buffers, and shuffling only immediately-neighbouring buffers if possible. This
may result in some wastage of space, but is much more time-efficient for large
amounts of data.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position before which the data will be inserted: must
be in range zero to <code>Size()</code>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aDes </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, contains data to insert and specifies the length
of the data: the length in the descriptor is overridden if <code>aLength</code>
is also specified </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, the length of the data to insert </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aPtr </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, the address of the data to insert </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If the insertion requires space beyond that already contained
in the buffer, and the necessary allocation or re-allocation fails, then a
leave occurs. </p></td>
</tr>
</table></td></tr></table>
<a name="2.6.3"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aWrite%28%29"></a>
<hr size="1" noshade>
<h3><code>Write()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void Write(TInt aPos,const TDesC8&amp; aDes);<br>void Write(TInt aPos,const TDesC8&amp; aDes,TInt aLength);<br>void Write(TInt aPos,const TAny* aPtr,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Writes data from a descriptor to the buffer&nbsp;&#8212;
overloaded function. The existing data from the insertion position, for as many
bytes as there are data in the descriptor, is overwritten.</p>
<p>Notes:</p>
<ul>
<li>
<p>No new space is allocated: this function cannot fail
(provided the parameters are specified within the bounds of the buffer and
descriptor).</p>
</li>
<li>
<p>No shuffling occurs: new data is written to the memory
locations occupied by the data it overwrites.</p>
</li>
</ul>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position at which data will begin to be written: must be
in range zero to <code>Size()</code> minus the length of the data to write
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TDesC8&amp; aDes </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, contains data to write and specifies the length of
the data: the length in the descriptor is overridden if <code>aLength</code> is
also specified </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, the length of the data to write </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aPtr </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, the address of the data to write </p></td>
</tr>
</table></td></tr></table>
<a name="2.6.4"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aRead%28%29"></a>
<hr size="1" noshade>
<h3><code>Read()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void Read(TInt aPos,TDes8&amp; aDes) const;<br>void Read(TInt aPos,TDes8&amp; aDes,TInt aLength) const;<br>void Read(TInt aPos,TAny* aPtr,TInt aLength) const;</code></p><h4 class="subheading">Description</h4>
<p>Reads data from the buffer into a descriptor&nbsp;&#8212;
overloaded function. Data from the buffer position is transferred into the
descriptor, for as many bytes as the maximum length of the descriptor, or the
length argument specified in the call.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position from which data is read: must be in range zero to
<code>Size()</code> minus the length of the data to read </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TDes8&amp; aDes </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, on return, contains data read from the buffer; on
call, its <code>MaxLength()</code> specifies the amount of data to be read:
this is overridden if <code>aLength</code> is also specified </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, the length of the data to read </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> const TAny* aPtr </code></td>
<td class="Cell"><p class="ValueDesc"> If specified, the address into which the data should be read
</p></td>
</tr>
</table></td></tr></table>
<a name="2.6.5"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aSize%28%29"></a>
<hr size="1" noshade>
<h3><code>Size()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>TInt Size() const;</code></p><h4 class="subheading">Description</h4>
<p>Returns the number of data bytes in the buffer.</p>
<p>Note:</p>
<p>The number of heap bytes used by the buffer may be greater than its
size, because there is typically extra room to allow for expansion. Use the
<code>Compress()</code> function to reduce the extra allocation as much as
possible</p>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt </code></td>
<td class="Cell"><p class="ValueDesc"> The number of data bytes in the buffer </p></td>
</tr>
</table></td></tr></table>
<a name="2.6.6"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aDelete%28%29"></a>
<hr size="1" noshade>
<h3><code>Delete()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void Delete(TInt aPos,TInt aLength)=0;</code></p><h4 class="subheading">Description</h4>
<p>Deletes data from the buffer. Data before the buffer position is not
affected. From the buffer position, the number of bytes specified are deleted.
Bytes beyond the deleted region are moved back to the buffer position. The size
of data in the buffer is thus reduced.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position where the deletion will begin: must be in the range
zero to <code>Size()</code> minus the length of the data to be deleted. </p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The number of bytes to delete: must be non-negative. </p></td>
</tr>
</table></td></tr></table>
<a name="2.6.7"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aReset%28%29"></a>
<hr size="1" noshade>
<h3><code>Reset()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void Reset();</code></p><h4 class="subheading">Description</h4>
<p>Deletes all data in the buffer. Its action is the same as
<code>Delete(0,Size())</code>. The buffer is compressed before the function
returns.</p>
<a name="2.7"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Mass operation support</h2>
</div><div class="Bodytext">
<a name="2.7.2"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aExpandL%28%29"></a>
<hr size="1" noshade>
<h3><code>ExpandL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void ExpandL(TInt aPos,TInt aLength);</code></p><h4 class="subheading">Description</h4>
<p>Inserts an uninitialised region into the buffer. Data at and beyond the
insertion position is moved to make way for the inserted region. Data before
the insertion position remains in place.</p>
<p>Note:</p>
<ul>
<li>
<p>The inserted region is not initialised. After using
<code>ExpandL()</code>, you should then use a series of <code>Write()</code>s
to fill this region with data.</p>
</li>
<li>
<p>Use <code>ExpandL()</code> followed by a series of
<code>Write()</code>s when you know the amount of data to be inserted, in
advance. It is more efficient than a series of <code>InsertL()</code>s. In
addition, once the result of the <code>ExpandL()</code> has been checked, it is
guaranteed that the <code>Write()</code>s do not leave, which can sometimes be
useful.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position before which the region will be inserted: must be in
range zero to <code>Size()</code>
</p></td>
</tr>
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aLength </code></td>
<td class="Cell"><p class="ValueDesc"> The length of the region to insert </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If the expansion requires space beyond that already contained in the
buffer, and the necessary allocation or re-allocation fails, then a leave
occurs. </p></td>
</tr>
</table></td></tr></table>
<a name="2.7.3"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aResizeL%28%29"></a>
<hr size="1" noshade>
<h3><code>ResizeL()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>void ResizeL(TInt aSize);</code></p><h4 class="subheading">Description</h4>
<p>Re-sizes the buffer to the specified size. The new size can be larger or
smaller than the existing size.</p>
<p>If the new size is larger than the existing size, the buffer is expanded
by adding uninitialised data to the end of it.</p>
<p>If the new size is smaller than the existing size, the buffer is reduced;
any data at the end of the buffer is lost.</p>
<p>Notes:</p>
<ul>
<li>
<p>If the new size is larger than the existing size, the function is
equivalent to <code>Delete(aSize,Size()-aSize)</code>.</p>
</li>
<li>
<p>If the new size is smaller than the existing size, the function is
equivalent to <code>ExpandL((Size(),aSize-Size())</code>.</p>
</li>
<li>
<p>The motivations for using <code>ResizeL()</code> are the same as those
for using <code>Delete()</code> and <code>ExpandL()</code>.</p>
</li>
</ul><h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aSize </code></td>
<td class="Cell"><p class="ValueDesc"> The new size of the buffer; this value must be greater than or equal to
zero. </p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Leave codes</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value">&nbsp;</code></td>
<td class="Cell"><p class="ValueDesc">If the expansion requires space beyond that already contained in the
buffer, and the necessary allocation or re-allocation fails, then a leave
occurs. </p></td>
</tr>
</table></td></tr></table>
<a name="2.8"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Compression</h2>
</div><div class="Bodytext">
<a name="2.8.2"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aCompress%28%29"></a>
<hr size="1" noshade>
<h3><code>Compress()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual void Compress()=0;</code></p><h4 class="subheading">Description</h4>
<p>Compresses the buffer so as to occupy minimal space. Normally, you would
do this when a buffer has reached its final size, or when you know it will not
expand again for a while, or when an out-of-memory error has occurred and your
program is taking measures to save space. Compression in these circumstances
releases memory for other programs to use, but has no adverse effect on
performance.</p>
<a name="2.9"></a>
</div><div class="Head2">
<table cellpadding="0" cellspacing="0" border="0" width="97%"><tr valign="bottom"><td align="right"><p><a href="#_top"><img alt="[Top]" src="../../../_stock/arrow_up_2.gif" border="0"align="bottom"></a></p></td></tr></table><hr size="2" noshade>
<h2>Pointer access</h2>
</div><div class="Bodytext">
<a name="2.9.2"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aPtr%28%29"></a>
<hr size="1" noshade>
<h3><code>Ptr()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TPtr8 Ptr(TInt aPos)=0;</code></p><h4 class="subheading">Description</h4>
<p>Returns a pointer descriptor which refers to all from the specified data
byte until the end of the contiguous region containing that byte. The
descriptor will point to the end of the segment containing the byte.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position: must be in range zero to <code>Size()</code>
</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TPtr8 </code></td>
<td class="Cell"><p class="ValueDesc"> Descriptor whose address points to the byte at the buffer position, and
whose length indicates the number of contiguous bytes stored in the buffer,
forward from that point. The length will be non-zero
unless<code>aPos==Size()</code>. </p></td>
</tr>
</table></td></tr></table>
<a name="2.9.3"></a></div><div class="Head3">
<a name="%3a%3aCBufBase%3a%3aBackPtr%28%29"></a>
<hr size="1" noshade>
<h3><code>BackPtr()</code></h3>
</div><div class="Bodytext"><p class="Prototype"><code>virtual TPtr8 BackPtr(TInt aPos)=0;</code></p><h4 class="subheading">Description</h4>
<p>Returns a pointer descriptor which refers to data from just before the
specified data byte backward until the beginning of the contiguous region
containing that byte.</p>
<h4 class="subheading">Parameters</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TInt aPos </code></td>
<td class="Cell"><p class="ValueDesc"> Buffer position: must be in range zero to <code>Size()</code>
</p></td>
</tr>
</table></td></tr></table>
<h4 class="subheading">Return value</h4>
<table cellpadding="0" border="0"
cellspacing="0"><tr><td class="ValueTableWrap"><table border="0"
cellpadding="5" cellspacing="1">
<tr valign="top">
<td class="Cell" ><code class="Value"> TPtr8 </code></td>
<td class="Cell"><p class="ValueDesc"> Descriptor containing address and length of backward contiguous region.
The address in the descriptor is the pointer to the bytes at the buffer
position, unless the buffer position was at the beginning of a non-first
segment in the buffer: in this case, the address is a pointer just beyond the
last data byte in the previous segment. The length is the number of contiguous
bytes from the address backwards to the beginning of the segment. </p></td>
</tr>
</table></td></tr></table>

</div><div class="Footer">
<hr noshade size="1">
<table cellpadding="0" cellspacing="0" border="0" width="100%">
<tr valign="bottom">
<td><p class="copyrightStatement">Copyright &copy;2002&nbsp; Symbian Ltd. &nbsp; &nbsp; &nbsp;	6.1-00174
</p></td>
<td align="right"><p><a href="#_top"><img
alt="[Top]" src="../../../_stock/arrow_up.gif" border="0"
align="bottom"></a></p></td>
</table>
</div>
</body>
</html>
